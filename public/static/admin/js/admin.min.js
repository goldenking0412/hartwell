/*!
 * ------/ Source: plugins/swipe.js
 */
/*
 * Swipe 2.0
 *
 * Brad Birdsall
 * Copyright 2013, MIT License
 *
*/
function Swipe(container, options) {
    "use strict";
    // utilities
    var noop = function() {};
    // simple no operation function
    var offloadFn = function(fn) {
        setTimeout(fn || noop, 0);
    };
    // offload a functions execution
    // check browser capabilities
    var browser = {
        addEventListener: !!window.addEventListener,
        touch: "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch,
        transitions: function(temp) {
            var props = [ "transitionProperty", "WebkitTransition", "MozTransition", "OTransition", "msTransition" ];
            for (var i in props) if (temp.style[props[i]] !== undefined) return true;
            return false;
        }(document.createElement("swipe"))
    };
    // quit if no root element
    if (!container) return;
    var element = container.children[0];
    var slides, slidePos, width, length;
    options = options || {};
    var index = parseInt(options.startSlide, 10) || 0;
    var speed = options.speed || 300;
    options.continuous = options.continuous !== undefined ? options.continuous : true;
    function setup() {
        // cache slides
        slides = element.children;
        length = slides.length;
        // set continuous to false if only one slide
        if (slides.length < 2) options.continuous = false;
        //special case if two slides
        if (browser.transitions && options.continuous && slides.length < 3) {
            element.appendChild(slides[0].cloneNode(true));
            element.appendChild(element.children[1].cloneNode(true));
            slides = element.children;
        }
        // create an array to store current positions of each slide
        slidePos = new Array(slides.length);
        // determine width of each slide
        width = container.getBoundingClientRect().width || container.offsetWidth;
        element.style.width = slides.length * width + "px";
        // stack elements
        var pos = slides.length;
        while (pos--) {
            var slide = slides[pos];
            slide.style.width = width + "px";
            slide.setAttribute("data-index", pos);
            if (browser.transitions) {
                slide.style.left = pos * -width + "px";
                move(pos, index > pos ? -width : index < pos ? width : 0, 0);
            }
        }
        // reposition elements before and after index
        if (options.continuous && browser.transitions) {
            move(circle(index - 1), -width, 0);
            move(circle(index + 1), width, 0);
        }
        if (!browser.transitions) element.style.left = index * -width + "px";
        container.style.visibility = "visible";
    }
    function prev() {
        if (options.continuous) slide(index - 1); else if (index) slide(index - 1);
    }
    function next() {
        if (options.continuous) slide(index + 1); else if (index < slides.length - 1) slide(index + 1);
    }
    function circle(index) {
        // a simple positive modulo using slides.length
        return (slides.length + index % slides.length) % slides.length;
    }
    function slide(to, slideSpeed) {
        // do nothing if already on requested slide
        if (index == to) return;
        if (browser.transitions) {
            var direction = Math.abs(index - to) / (index - to);
            // 1: backward, -1: forward
            // get the actual position of the slide
            if (options.continuous) {
                var natural_direction = direction;
                direction = -slidePos[circle(to)] / width;
                // if going forward but to < index, use to = slides.length + to
                // if going backward but to > index, use to = -slides.length + to
                if (direction !== natural_direction) to = -direction * slides.length + to;
            }
            var diff = Math.abs(index - to) - 1;
            // move all the slides between index and to in the right direction
            while (diff--) move(circle((to > index ? to : index) - diff - 1), width * direction, 0);
            to = circle(to);
            move(index, width * direction, slideSpeed || speed);
            move(to, 0, slideSpeed || speed);
            if (options.continuous) move(circle(to - direction), -(width * direction), 0);
        } else {
            to = circle(to);
            animate(index * -width, to * -width, slideSpeed || speed);
        }
        index = to;
        offloadFn(options.callback && options.callback(index, slides[index]));
    }
    function move(index, dist, speed) {
        translate(index, dist, speed);
        slidePos[index] = dist;
    }
    function translate(index, dist, speed) {
        var slide = slides[index];
        var style = slide && slide.style;
        if (!style) return;
        style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + "ms";
        style.webkitTransform = "translate(" + dist + "px,0)" + "translateZ(0)";
        style.msTransform = style.MozTransform = style.OTransform = "translateX(" + dist + "px)";
    }
    function animate(from, to, speed) {
        // if not an animation, just reposition
        if (!speed) {
            element.style.left = to + "px";
            return;
        }
        var start = +new Date();
        var timer = setInterval(function() {
            var timeElap = +new Date() - start;
            if (timeElap > speed) {
                element.style.left = to + "px";
                if (delay) begin();
                options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
                clearInterval(timer);
                return;
            }
            element.style.left = (to - from) * (Math.floor(timeElap / speed * 100) / 100) + from + "px";
        }, 4);
    }
    // setup auto slideshow
    var delay = options.auto || 0;
    var interval;
    function begin() {
        interval = setTimeout(next, delay);
    }
    function stop() {
        delay = 0;
        clearTimeout(interval);
    }
    // setup initial vars
    var start = {};
    var delta = {};
    var isScrolling;
    // setup event capturing
    var events = {
        handleEvent: function(event) {
            switch (event.type) {
              case "touchstart":
                this.start(event);
                break;

              case "touchmove":
                this.move(event);
                break;

              case "touchend":
                offloadFn(this.end(event));
                break;

              case "webkitTransitionEnd":
              case "msTransitionEnd":
              case "oTransitionEnd":
              case "otransitionend":
              case "transitionend":
                offloadFn(this.transitionEnd(event));
                break;

              case "resize":
                offloadFn(setup);
                break;
            }
            if (options.stopPropagation) event.stopPropagation();
        },
        start: function(event) {
            var touches = event.touches[0];
            // measure start values
            start = {
                // get initial touch coords
                x: touches.pageX,
                y: touches.pageY,
                // store time to determine touch duration
                time: +new Date()
            };
            // used for testing first move event
            isScrolling = undefined;
            // reset delta and end measurements
            delta = {};
            // attach touchmove and touchend listeners
            element.addEventListener("touchmove", this, false);
            element.addEventListener("touchend", this, false);
        },
        move: function(event) {
            // ensure swiping with one touch and not pinching
            if (event.touches.length > 1 || event.scale && event.scale !== 1) return;
            if (options.disableScroll) event.preventDefault();
            var touches = event.touches[0];
            // measure change in x and y
            delta = {
                x: touches.pageX - start.x,
                y: touches.pageY - start.y
            };
            // determine if scrolling test has run - one time test
            if (typeof isScrolling == "undefined") {
                isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
            }
            // if user is not trying to scroll vertically
            if (!isScrolling) {
                // prevent native scrolling
                event.preventDefault();
                // stop slideshow
                stop();
                // increase resistance if first or last slide
                if (options.continuous) {
                    // we don't add resistance at the end
                    translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);
                    translate(index, delta.x + slidePos[index], 0);
                    translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);
                } else {
                    delta.x = delta.x / (!index && delta.x > 0 || index == slides.length - 1 && delta.x < 0 ? Math.abs(delta.x) / width + 1 : 1);
                    // no resistance if false
                    // translate 1:1
                    translate(index - 1, delta.x + slidePos[index - 1], 0);
                    translate(index, delta.x + slidePos[index], 0);
                    translate(index + 1, delta.x + slidePos[index + 1], 0);
                }
            }
        },
        end: function(event) {
            // measure duration
            var duration = +new Date() - start.time;
            // determine if slide attempt triggers next/prev slide
            var isValidSlide = Number(duration) < 250 && Math.abs(delta.x) > 20 || Math.abs(delta.x) > width / 2;
            // or if slide amt is greater than half the width
            // determine if slide attempt is past start and end
            var isPastBounds = !index && delta.x > 0 || index == slides.length - 1 && delta.x < 0;
            // or if last slide and slide amt is less than 0
            if (options.continuous) isPastBounds = false;
            // determine direction of swipe (true:right, false:left)
            var direction = delta.x < 0;
            // if not scrolling vertically
            if (!isScrolling) {
                if (isValidSlide && !isPastBounds) {
                    if (direction) {
                        if (options.continuous) {
                            // we need to get the next in this direction in place
                            move(circle(index - 1), -width, 0);
                            move(circle(index + 2), width, 0);
                        } else {
                            move(index - 1, -width, 0);
                        }
                        move(index, slidePos[index] - width, speed);
                        move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);
                        index = circle(index + 1);
                    } else {
                        if (options.continuous) {
                            // we need to get the next in this direction in place
                            move(circle(index + 1), width, 0);
                            move(circle(index - 2), -width, 0);
                        } else {
                            move(index + 1, width, 0);
                        }
                        move(index, slidePos[index] + width, speed);
                        move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);
                        index = circle(index - 1);
                    }
                    options.callback && options.callback(index, slides[index]);
                } else {
                    if (options.continuous) {
                        move(circle(index - 1), -width, speed);
                        move(index, 0, speed);
                        move(circle(index + 1), width, speed);
                    } else {
                        move(index - 1, -width, speed);
                        move(index, 0, speed);
                        move(index + 1, width, speed);
                    }
                }
            }
            // kill touchmove and touchend event listeners until touchstart called again
            element.removeEventListener("touchmove", events, false);
            element.removeEventListener("touchend", events, false);
        },
        transitionEnd: function(event) {
            if (parseInt(event.target.getAttribute("data-index"), 10) == index) {
                if (delay) begin();
                options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
            }
        }
    };
    // trigger setup
    setup();
    // start auto slideshow if applicable
    if (delay) begin();
    // add event listeners
    if (browser.addEventListener) {
        // set touchstart event on element
        if (browser.touch) element.addEventListener("touchstart", events, false);
        if (browser.transitions) {
            element.addEventListener("webkitTransitionEnd", events, false);
            element.addEventListener("msTransitionEnd", events, false);
            element.addEventListener("oTransitionEnd", events, false);
            element.addEventListener("otransitionend", events, false);
            element.addEventListener("transitionend", events, false);
        }
        // set resize event on window
        window.addEventListener("resize", events, false);
    } else {
        window.onresize = function() {
            setup();
        };
    }
    // expose the Swipe API
    return {
        setup: function() {
            setup();
        },
        slide: function(to, speed) {
            // cancel slideshow
            stop();
            slide(to, speed);
        },
        prev: function() {
            // cancel slideshow
            stop();
            prev();
        },
        next: function() {
            // cancel slideshow
            stop();
            next();
        },
        stop: function() {
            // cancel slideshow
            stop();
        },
        resume: function() {
            // start slideshow
            delay = options.auto || 0;
            begin();
        },
        getPos: function() {
            // return current index position
            return index;
        },
        getNumSlides: function() {
            // return total number of slides
            return length;
        },
        kill: function() {
            // cancel slideshow
            stop();
            // reset element
            element.style.width = "";
            element.style.left = "";
            // reset slides
            var pos = slides.length;
            while (pos--) {
                var slide = slides[pos];
                slide.style.width = "";
                slide.style.left = "";
                if (browser.transitions) translate(pos, 0, 0);
            }
            // removed event listeners
            if (browser.addEventListener) {
                // remove current event listeners
                element.removeEventListener("touchstart", events, false);
                element.removeEventListener("webkitTransitionEnd", events, false);
                element.removeEventListener("msTransitionEnd", events, false);
                element.removeEventListener("oTransitionEnd", events, false);
                element.removeEventListener("otransitionend", events, false);
                element.removeEventListener("transitionend", events, false);
                window.removeEventListener("resize", events, false);
            } else {
                window.onresize = null;
            }
        }
    };
}

if (window.jQuery || window.Zepto) {
    (function($) {
        $.fn.Swipe = function(params) {
            return this.each(function() {
                $(this).data("Swipe", new Swipe($(this)[0], params));
            });
        };
    })(window.jQuery || window.Zepto);
}

(function(window, document, $) {
    var isInputSupported = "placeholder" in document.createElement("input"), isTextareaSupported = "placeholder" in document.createElement("textarea"), prototype = $.fn, valHooks = $.valHooks, hooks, placeholder;
    if (isInputSupported && isTextareaSupported) {
        placeholder = prototype.placeholder = function() {
            return this;
        };
        placeholder.input = placeholder.textarea = true;
    } else {
        placeholder = prototype.placeholder = function() {
            var $this = this;
            $this.filter((isInputSupported ? "textarea" : ":input") + "[placeholder]").not(".placeholder").bind({
                "focus.placeholder": clearPlaceholder,
                "blur.placeholder": setPlaceholder
            }).data("placeholder-enabled", true).trigger("blur.placeholder");
            return $this;
        };
        placeholder.input = isInputSupported;
        placeholder.textarea = isTextareaSupported;
        hooks = {
            get: function(element) {
                var $element = $(element);
                return $element.data("placeholder-enabled") && $element.hasClass("placeholder") ? "" : element.value;
            },
            set: function(element, value) {
                var $element = $(element);
                if (!$element.data("placeholder-enabled")) {
                    return element.value = value;
                }
                if (value == "") {
                    element.value = value;
                    // Issue #56: Setting the placeholder causes problems if the element continues to have focus.
                    if (element != document.activeElement) {
                        // We can't use `triggerHandler` here because of dummy text/password inputs :(
                        setPlaceholder.call(element);
                    }
                } else if ($element.hasClass("placeholder")) {
                    clearPlaceholder.call(element, true, value) || (element.value = value);
                } else {
                    element.value = value;
                }
                // `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
                return $element;
            }
        };
        isInputSupported || (valHooks.input = hooks);
        isTextareaSupported || (valHooks.textarea = hooks);
        $(function() {
            // Look for forms
            $(document).delegate("form", "submit.placeholder", function() {
                // Clear the placeholder values so they don't get submitted
                var $inputs = $(".placeholder", this).each(clearPlaceholder);
                setTimeout(function() {
                    $inputs.each(setPlaceholder);
                }, 10);
            });
        });
        // Clear placeholder values upon page reload
        $(window).bind("beforeunload.placeholder", function() {
            $(".placeholder").each(function() {
                this.value = "";
            });
        });
    }
    function args(elem) {
        // Return an object of element attributes
        var newAttrs = {}, rinlinejQuery = /^jQuery\d+$/;
        $.each(elem.attributes, function(i, attr) {
            if (attr.specified && !rinlinejQuery.test(attr.name)) {
                newAttrs[attr.name] = attr.value;
            }
        });
        return newAttrs;
    }
    function clearPlaceholder(event, value) {
        var input = this, $input = $(input);
        if (input.value == $input.attr("placeholder") && $input.hasClass("placeholder")) {
            if ($input.data("placeholder-password")) {
                $input = $input.hide().next().show().attr("id", $input.removeAttr("id").data("placeholder-id"));
                // If `clearPlaceholder` was called from `$.valHooks.input.set`
                if (event === true) {
                    return $input[0].value = value;
                }
                $input.focus();
            } else {
                input.value = "";
                $input.removeClass("placeholder");
                input == document.activeElement && input.select();
            }
        }
    }
    function setPlaceholder() {
        var $replacement, input = this, $input = $(input), $origInput = $input, id = this.id;
        if (input.value == "") {
            if (input.type == "password") {
                if (!$input.data("placeholder-textinput")) {
                    try {
                        $replacement = $input.clone().attr({
                            type: "text"
                        });
                    } catch (e) {
                        $replacement = $("<input>").attr($.extend(args(this), {
                            type: "text"
                        }));
                    }
                    $replacement.removeAttr("name").data({
                        "placeholder-password": true,
                        "placeholder-id": id
                    }).bind("focus.placeholder", clearPlaceholder);
                    $input.data({
                        "placeholder-textinput": $replacement,
                        "placeholder-id": id
                    }).before($replacement);
                }
                $input = $input.removeAttr("id").hide().prev().attr("id", id).show();
            }
            $input.addClass("placeholder");
            $input[0].value = $input.attr("placeholder");
        } else {
            $input.removeClass("placeholder");
        }
    }
})(this, document, jQuery);

//! END
/*!
 * ------/ Source: plugins/fineuploader.min.js
 */
var qq = function(a) {
    return {
        hide: function() {
            a.style.display = "none";
            return this;
        },
        attach: function(b, c) {
            a.addEventListener ? a.addEventListener(b, c, !1) : a.attachEvent && a.attachEvent("on" + b, c);
            return function() {
                qq(a).detach(b, c);
            };
        },
        detach: function(b, c) {
            a.removeEventListener ? a.removeEventListener(b, c, !1) : a.attachEvent && a.detachEvent("on" + b, c);
            return this;
        },
        contains: function(b) {
            return a === b ? !0 : a.contains ? a.contains(b) : !!(b.compareDocumentPosition(a) & 8);
        },
        insertBefore: function(b) {
            b.parentNode.insertBefore(a, b);
            return this;
        },
        remove: function() {
            a.parentNode.removeChild(a);
            return this;
        },
        css: function(b) {
            null != b.opacity && ("string" !== typeof a.style.opacity && "undefined" !== typeof a.filters) && (b.filter = "alpha(opacity=" + Math.round(100 * b.opacity) + ")");
            qq.extend(a.style, b);
            return this;
        },
        hasClass: function(b) {
            return RegExp("(^| )" + b + "( |$)").test(a.className);
        },
        addClass: function(b) {
            qq(a).hasClass(b) || (a.className += " " + b);
            return this;
        },
        removeClass: function(b) {
            a.className = a.className.replace(RegExp("(^| )" + b + "( |$)"), " ").replace(/^\s+|\s+$/g, "");
            return this;
        },
        getByClass: function(b) {
            var c, d = [];
            if (a.querySelectorAll) return a.querySelectorAll("." + b);
            c = a.getElementsByTagName("*");
            qq.each(c, function(a, c) {
                qq(c).hasClass(b) && d.push(c);
            });
            return d;
        },
        children: function() {
            for (var b = [], c = a.firstChild; c; ) 1 === c.nodeType && b.push(c), c = c.nextSibling;
            return b;
        },
        setText: function(b) {
            a.innerText = b;
            a.textContent = b;
            return this;
        },
        clearText: function() {
            return qq(a).setText("");
        }
    };
};

qq.log = function(a, b) {
    if (window.console) if (!b || "info" === b) window.console.log(a); else if (window.console[b]) window.console[b](a); else window.console.log("<" + b + "> " + a);
};

qq.isObject = function(a) {
    return a && !a.nodeType && "[object Object]" === Object.prototype.toString.call(a);
};

qq.isFunction = function(a) {
    return "function" === typeof a;
};

qq.isArray = function(a) {
    return "[object Array]" === Object.prototype.toString.call(a);
};

qq.isString = function(a) {
    return "[object String]" === Object.prototype.toString.call(a);
};

qq.trimStr = function(a) {
    return String.prototype.trim ? a.trim() : a.replace(/^\s+|\s+$/g, "");
};

qq.isFile = function(a) {
    return window.File && "[object File]" === Object.prototype.toString.call(a);
};

qq.isFileList = function(a) {
    return window.FileList && "[object FileList]" === Object.prototype.toString.call(a);
};

qq.isFileOrInput = function(a) {
    return qq.isFile(a) || qq.isInput(a);
};

qq.isInput = function(a) {
    return window.HTMLInputElement && "[object HTMLInputElement]" === Object.prototype.toString.call(a) && a.type && "file" === a.type.toLowerCase() || a.tagName && "input" === a.tagName.toLowerCase() && a.type && "file" === a.type.toLowerCase() ? !0 : !1;
};

qq.isBlob = function(a) {
    return window.Blob && "[object Blob]" === Object.prototype.toString.call(a);
};

qq.isXhrUploadSupported = function() {
    var a = document.createElement("input");
    a.type = "file";
    return void 0 !== a.multiple && "undefined" !== typeof File && "undefined" !== typeof FormData && "undefined" !== typeof new XMLHttpRequest().upload;
};

qq.isFolderDropSupported = function(a) {
    return a.items && a.items[0].webkitGetAsEntry;
};

qq.isFileChunkingSupported = function() {
    return !qq.android() && qq.isXhrUploadSupported() && (void 0 !== File.prototype.slice || void 0 !== File.prototype.webkitSlice || void 0 !== File.prototype.mozSlice);
};

qq.extend = function(a, b, c) {
    qq.each(b, function(b, e) {
        c && qq.isObject(e) ? (void 0 === a[b] && (a[b] = {}), qq.extend(a[b], e, !0)) : a[b] = e;
    });
    return a;
};

qq.indexOf = function(a, b, c) {
    if (a.indexOf) return a.indexOf(b, c);
    var c = c || 0, d = a.length;
    for (0 > c && (c += d); c < d; c += 1) if (a.hasOwnProperty(c) && a[c] === b) return c;
    return -1;
};

qq.getUniqueId = function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a) {
        var b = 16 * Math.random() | 0;
        return ("x" == a ? b : b & 3 | 8).toString(16);
    });
};

qq.ie = function() {
    return -1 !== navigator.userAgent.indexOf("MSIE");
};

qq.ie10 = function() {
    return -1 !== navigator.userAgent.indexOf("MSIE 10");
};

qq.safari = function() {
    return void 0 !== navigator.vendor && -1 !== navigator.vendor.indexOf("Apple");
};

qq.chrome = function() {
    return void 0 !== navigator.vendor && -1 !== navigator.vendor.indexOf("Google");
};

qq.firefox = function() {
    return -1 !== navigator.userAgent.indexOf("Mozilla") && void 0 !== navigator.vendor && "" === navigator.vendor;
};

qq.windows = function() {
    return "Win32" === navigator.platform;
};

qq.android = function() {
    return -1 !== navigator.userAgent.toLowerCase().indexOf("android");
};

qq.ios = function() {
    return -1 !== navigator.userAgent.indexOf("iPad") || -1 !== navigator.userAgent.indexOf("iPod") || -1 !== navigator.userAgent.indexOf("iPhone");
};

qq.preventDefault = function(a) {
    a.preventDefault ? a.preventDefault() : a.returnValue = !1;
};

qq.toElement = function() {
    var a = document.createElement("div");
    return function(b) {
        a.innerHTML = b;
        b = a.firstChild;
        a.removeChild(b);
        return b;
    };
}();

qq.each = function(a, b) {
    var c, d;
    if (a) if (qq.isArray(a)) for (c = 0; c < a.length && !(d = b(c, a[c]), !1 === d); c++) ; else for (c in a) if (Object.prototype.hasOwnProperty.call(a, c) && (d = b(c, a[c]), 
    !1 === d)) break;
};

qq.bind = function(a, b) {
    if (qq.isFunction(a)) {
        var c = Array.prototype.slice.call(arguments, 2);
        return function() {
            arguments.length && (c = c.concat(Array.prototype.slice.call(arguments)));
            return a.apply(b, c);
        };
    }
    throw Error("first parameter must be a function!");
};

qq.obj2url = function(a, b, c) {
    var d, e = [], f = "&", g = function(a, c) {
        var d = b ? /\[\]$/.test(b) ? b : b + "[" + c + "]" : c;
        "undefined" !== d && "undefined" !== c && e.push("object" === typeof a ? qq.obj2url(a, d, !0) : "[object Function]" === Object.prototype.toString.call(a) ? encodeURIComponent(d) + "=" + encodeURIComponent(a()) : encodeURIComponent(d) + "=" + encodeURIComponent(a));
    };
    if (!c && b) f = /\?/.test(b) ? /\?$/.test(b) ? "" : "&" : "?", e.push(b), e.push(qq.obj2url(a)); else if ("[object Array]" === Object.prototype.toString.call(a) && "undefined" !== typeof a) {
        d = -1;
        for (c = a.length; d < c; d += 1) g(a[d], d);
    } else if ("undefined" !== typeof a && null !== a && "object" === typeof a) for (d in a) a.hasOwnProperty(d) && g(a[d], d); else e.push(encodeURIComponent(b) + "=" + encodeURIComponent(a));
    return b ? e.join(f) : e.join(f).replace(/^&/, "").replace(/%20/g, "+");
};

qq.obj2FormData = function(a, b, c) {
    b || (b = new FormData());
    qq.each(a, function(a, e) {
        a = c ? c + "[" + a + "]" : a;
        qq.isObject(e) ? qq.obj2FormData(e, b, a) : qq.isFunction(e) ? b.append(a, e()) : b.append(a, e);
    });
    return b;
};

qq.obj2Inputs = function(a, b) {
    var c;
    b || (b = document.createElement("form"));
    qq.obj2FormData(a, {
        append: function(a, e) {
            c = document.createElement("input");
            c.setAttribute("name", a);
            c.setAttribute("value", e);
            b.appendChild(c);
        }
    });
    return b;
};

qq.setCookie = function(a, b, c) {
    var d = new Date(), e = "";
    c && (d.setTime(d.getTime() + 864e5 * c), e = "; expires=" + d.toGMTString());
    document.cookie = a + "=" + b + e + "; path=/";
};

qq.getCookie = function(a) {
    var b = a + "=", a = document.cookie.split(";"), c;
    qq.each(a, function(a, e) {
        for (var f = e; " " == f.charAt(0); ) f = f.substring(1, f.length);
        if (0 === f.indexOf(b)) return c = f.substring(b.length, f.length), !1;
    });
    return c;
};

qq.getCookieNames = function(a) {
    var b = document.cookie.split(";"), c = [];
    qq.each(b, function(b, e) {
        var e = qq.trimStr(e), f = e.indexOf("=");
        e.match(a) && c.push(e.substr(0, f));
    });
    return c;
};

qq.deleteCookie = function(a) {
    qq.setCookie(a, "", -1);
};

qq.areCookiesEnabled = function() {
    var a = "qqCookieTest:" + 1e5 * Math.random();
    qq.setCookie(a, 1);
    return qq.getCookie(a) ? (qq.deleteCookie(a), !0) : !1;
};

qq.parseJson = function(a) {
    return window.JSON && qq.isFunction(JSON.parse) ? JSON.parse(a) : eval("(" + a + ")");
};

qq.DisposeSupport = function() {
    var a = [];
    return {
        dispose: function() {
            var b;
            do (b = a.shift()) && b(); while (b);
        },
        attach: function() {
            this.addDisposer(qq(arguments[0]).attach.apply(this, Array.prototype.slice.call(arguments, 1)));
        },
        addDisposer: function(b) {
            a.push(b);
        }
    };
};

qq.version = "3.6.4";

qq.supportedFeatures = function() {
    var a, b, c, d, e, f;
    a = !0;
    try {
        b = document.createElement("input"), b.type = "file", qq(b).hide(), b.disabled && (a = !1);
    } catch (g) {
        a = !1;
    }
    c = (b = a && qq.isXhrUploadSupported()) && qq.chrome() && void 0 !== navigator.userAgent.match(/Chrome\/[2][1-9]|Chrome\/[3-9][0-9]/);
    d = b && qq.isFileChunkingSupported();
    e = b && d && qq.areCookiesEnabled();
    f = b && qq.chrome() && void 0 !== navigator.userAgent.match(/Chrome\/[1][4-9]|Chrome\/[2-9][0-9]/);
    return {
        uploading: a,
        ajaxUploading: b,
        fileDrop: b,
        folderDrop: c,
        chunking: d,
        resume: e,
        uploadCustomHeaders: b,
        uploadNonMultipart: b,
        itemSizeValidation: b,
        uploadViaPaste: f,
        progressBar: b,
        uploadCors: a && (void 0 !== window.postMessage || b),
        deleteFileCors: b,
        canDetermineSize: b
    };
}();

qq.Promise = function() {
    var a, b, c = [], d = [], e = [], f = 0;
    return {
        then: function(e, i) {
            0 === f ? (e && c.push(e), i && d.push(i)) : -1 === f && i ? i(b) : e && e(a);
            return this;
        },
        done: function(a) {
            0 === f ? e.push(a) : a();
            return this;
        },
        success: function(b) {
            f = 1;
            a = b;
            c.length && qq.each(c, function(a, c) {
                c(b);
            });
            e.length && qq.each(e, function(a, b) {
                b();
            });
            return this;
        },
        failure: function(a) {
            f = -1;
            b = a;
            d.length && qq.each(d, function(b, c) {
                c(a);
            });
            e.length && qq.each(e, function(a, b) {
                b();
            });
            return this;
        }
    };
};

qq.isPromise = function(a) {
    return a && a.then && a.done;
};

qq.UploadButton = function(a) {
    function b() {
        var a = document.createElement("input");
        e.multiple && a.setAttribute("multiple", "multiple");
        e.acceptFiles && a.setAttribute("accept", e.acceptFiles);
        a.setAttribute("type", "file");
        a.setAttribute("name", e.name);
        qq(a).css({
            position: "absolute",
            right: 0,
            top: 0,
            fontFamily: "Arial",
            fontSize: "118px",
            margin: 0,
            padding: 0,
            cursor: "pointer",
            opacity: 0
        });
        e.element.appendChild(a);
        d.attach(a, "change", function() {
            e.onChange(a);
        });
        d.attach(a, "mouseover", function() {
            qq(e.element).addClass(e.hoverClass);
        });
        d.attach(a, "mouseout", function() {
            qq(e.element).removeClass(e.hoverClass);
        });
        d.attach(a, "focus", function() {
            qq(e.element).addClass(e.focusClass);
        });
        d.attach(a, "blur", function() {
            qq(e.element).removeClass(e.focusClass);
        });
        window.attachEvent && a.setAttribute("tabIndex", "-1");
        return a;
    }
    var c, d = new qq.DisposeSupport(), e = {
        element: null,
        multiple: !1,
        acceptFiles: null,
        name: "file",
        onChange: function() {},
        hoverClass: "qq-upload-button-hover",
        focusClass: "qq-upload-button-focus"
    };
    qq.extend(e, a);
    qq(e.element).css({
        position: "relative",
        overflow: "hidden",
        direction: "ltr"
    });
    c = b();
    return {
        getInput: function() {
            return c;
        },
        reset: function() {
            c.parentNode && qq(c).remove();
            qq(e.element).removeClass(e.focusClass);
            c = b();
        }
    };
};

qq.PasteSupport = function(a) {
    var b;
    b = {
        targetElement: null,
        callbacks: {
            log: function() {},
            pasteReceived: function() {}
        }
    };
    qq.extend(b, a);
    (function() {
        qq(b.targetElement).attach("paste", function(a) {
            (a = a.clipboardData) && qq.each(a.items, function(a, c) {
                if (c.type && 0 === c.type.indexOf("image/")) {
                    var f = c.getAsFile();
                    b.callbacks.pasteReceived(f);
                }
            });
        });
    })();
    return {
        reset: function() {}
    };
};

qq.UploadData = function(a) {
    function b(a) {
        if (qq.isArray(a)) {
            var b = [];
            qq.each(a, function(a, c) {
                b.push(e[f[c]]);
            });
            return b;
        }
        return e[f[a]];
    }
    function c(a) {
        if (qq.isArray(a)) {
            var b = [];
            qq.each(a, function(a, c) {
                b.push(e[g[c]]);
            });
            return b;
        }
        return e[g[a]];
    }
    function d(a) {
        var b = [], a = [].concat(a);
        qq.each(a, function(a, c) {
            var d = i[c];
            void 0 !== d && qq.each(d, function(a, c) {
                b.push(e[c]);
            });
        });
        return b;
    }
    var e = [], f = {}, g = {}, i = {};
    return {
        added: function(b) {
            var c = a.getUuid(b), d = a.getName(b), n = a.getSize(b), q = qq.status.SUBMITTING, d = e.push({
                id: b,
                name: d,
                uuid: c,
                size: n,
                status: q
            }) - 1;
            f[b] = d;
            g[c] = d;
            void 0 === i[q] && (i[q] = []);
            i[q].push(d);
            a.onStatusChange(b, void 0, q);
        },
        retrieve: function(a) {
            if (qq.isObject(a) && e.length) {
                if (void 0 !== a.id) return b(a.id);
                if (void 0 !== a.uuid) return c(a.uuid);
                if (a.status) return d(a.status);
            } else return qq.extend([], e, !0);
        },
        reset: function() {
            e = [];
            f = {};
            g = {};
            i = {};
        },
        setStatus: function(b, c) {
            var d = f[b], n = e[d].status, g = qq.indexOf(i[n], d);
            i[n].splice(g, 1);
            e[d].status = c;
            void 0 === i[c] && (i[c] = []);
            i[c].push(d);
            a.onStatusChange(b, n, c);
        },
        uuidChanged: function(a, b) {
            var c = f[a], d = e[c].uuid;
            e[c].uuid = b;
            g[b] = c;
            delete g[d];
        }
    };
};

qq.status = {
    SUBMITTING: "submitting",
    SUBMITTED: "submitted",
    REJECTED: "rejected",
    QUEUED: "queued",
    CANCELED: "canceled",
    UPLOADING: "uploading",
    UPLOAD_RETRYING: "retrying upload",
    UPLOAD_SUCCESSFUL: "upload successful",
    UPLOAD_FAILED: "upload failed",
    DELETE_FAILED: "delete failed",
    DELETING: "deleting",
    DELETED: "deleted"
};

qq.FineUploaderBasic = function(a) {
    this._options = {
        debug: !1,
        button: null,
        multiple: !0,
        maxConnections: 3,
        disableCancelForFormUploads: !1,
        autoUpload: !0,
        request: {
            endpoint: "/server/upload",
            params: {},
            paramsInBody: !0,
            customHeaders: {},
            forceMultipart: !0,
            inputName: "qqfile",
            uuidName: "qquuid",
            totalFileSizeName: "qqtotalfilesize"
        },
        validation: {
            allowedExtensions: [],
            sizeLimit: 0,
            minSizeLimit: 0,
            itemLimit: 0,
            stopOnFirstInvalidFile: !0,
            acceptFiles: null
        },
        callbacks: {
            onSubmit: function() {},
            onSubmitted: function() {},
            onComplete: function() {},
            onCancel: function() {},
            onUpload: function() {},
            onUploadChunk: function() {},
            onResume: function() {},
            onProgress: function() {},
            onError: function() {},
            onAutoRetry: function() {},
            onManualRetry: function() {},
            onValidateBatch: function() {},
            onValidate: function() {},
            onSubmitDelete: function() {},
            onDelete: function() {},
            onDeleteComplete: function() {},
            onPasteReceived: function() {},
            onStatusChange: function() {}
        },
        messages: {
            typeError: "{file} has an invalid extension. Valid extension(s): {extensions}.",
            sizeError: "{file} is too large, maximum file size is {sizeLimit}.",
            minSizeError: "{file} is too small, minimum file size is {minSizeLimit}.",
            emptyError: "{file} is empty, please select files again without it.",
            noFilesError: "No files to upload.",
            tooManyItemsError: "Too many items ({netItems}) would be uploaded.  Item limit is {itemLimit}.",
            retryFailTooManyItems: "Retry failed - you have reached your file limit.",
            onLeave: "The files are being uploaded, if you leave now the upload will be cancelled."
        },
        retry: {
            enableAuto: !1,
            maxAutoAttempts: 3,
            autoAttemptDelay: 5,
            preventRetryResponseProperty: "preventRetry"
        },
        classes: {
            buttonHover: "qq-upload-button-hover",
            buttonFocus: "qq-upload-button-focus"
        },
        chunking: {
            enabled: !1,
            partSize: 2e6,
            paramNames: {
                partIndex: "qqpartindex",
                partByteOffset: "qqpartbyteoffset",
                chunkSize: "qqchunksize",
                totalFileSize: "qqtotalfilesize",
                totalParts: "qqtotalparts",
                filename: "qqfilename"
            }
        },
        resume: {
            enabled: !1,
            id: null,
            cookiesExpireIn: 7,
            paramNames: {
                resuming: "qqresume"
            }
        },
        formatFileName: function(a) {
            33 < a.length && (a = a.slice(0, 19) + "..." + a.slice(-14));
            return a;
        },
        text: {
            defaultResponseError: "Upload failure reason unknown",
            sizeSymbols: "kB MB GB TB PB EB".split(" ")
        },
        deleteFile: {
            enabled: !1,
            endpoint: "/server/upload",
            customHeaders: {},
            params: {}
        },
        cors: {
            expected: !1,
            sendCredentials: !1
        },
        blobs: {
            defaultName: "misc_data",
            paramNames: {
                name: "qqblobname"
            }
        },
        paste: {
            targetElement: null,
            defaultName: "pasted_image"
        },
        camera: {
            ios: !1
        }
    };
    qq.extend(this._options, a, !0);
    this._handleCameraAccess();
    this._wrapCallbacks();
    this._disposeSupport = new qq.DisposeSupport();
    this._filesInProgress = [];
    this._storedIds = [];
    this._autoRetries = [];
    this._retryTimeouts = [];
    this._preventRetries = [];
    this._netUploaded = this._netUploadedOrQueued = 0;
    this._uploadData = this._createUploadDataTracker();
    this._paramsStore = this._createParamsStore("request");
    this._deleteFileParamsStore = this._createParamsStore("deleteFile");
    this._endpointStore = this._createEndpointStore("request");
    this._deleteFileEndpointStore = this._createEndpointStore("deleteFile");
    this._handler = this._createUploadHandler();
    this._deleteHandler = this._createDeleteHandler();
    this._options.button && (this._button = this._createUploadButton(this._options.button));
    this._options.paste.targetElement && (this._pasteHandler = this._createPasteHandler());
    this._preventLeaveInProgress();
};

qq.FineUploaderBasic.prototype = {
    log: function(a, b) {
        this._options.debug && (!b || "info" === b) ? qq.log("[FineUploader " + qq.version + "] " + a) : b && "info" !== b && qq.log("[FineUploader " + qq.version + "] " + a, b);
    },
    setParams: function(a, b) {
        null == b ? this._options.request.params = a : this._paramsStore.setParams(a, b);
    },
    setDeleteFileParams: function(a, b) {
        null == b ? this._options.deleteFile.params = a : this._deleteFileParamsStore.setParams(a, b);
    },
    setEndpoint: function(a, b) {
        null == b ? this._options.request.endpoint = a : this._endpointStore.setEndpoint(a, b);
    },
    getInProgress: function() {
        return this._filesInProgress.length;
    },
    getNetUploads: function() {
        return this._netUploaded;
    },
    uploadStoredFiles: function() {
        for (var a; this._storedIds.length; ) a = this._storedIds.shift(), this._filesInProgress.push(a), 
        this._handler.upload(a);
    },
    clearStoredFiles: function() {
        this._storedIds = [];
    },
    retry: function(a) {
        return this._onBeforeManualRetry(a) ? (this._netUploadedOrQueued++, this._uploadData.setStatus(a, qq.status.UPLOAD_RETRYING), 
        this._handler.retry(a), !0) : !1;
    },
    cancel: function(a) {
        this._handler.cancel(a);
    },
    cancelAll: function() {
        var a = [], b = this;
        qq.extend(a, this._storedIds);
        qq.each(a, function(a, d) {
            b.cancel(d);
        });
        this._handler.cancelAll();
    },
    reset: function() {
        this.log("Resetting uploader...");
        this._handler.reset();
        this._filesInProgress = [];
        this._storedIds = [];
        this._autoRetries = [];
        this._retryTimeouts = [];
        this._preventRetries = [];
        this._button.reset();
        this._paramsStore.reset();
        this._endpointStore.reset();
        this._netUploaded = this._netUploadedOrQueued = 0;
        this._uploadData.reset();
        this._pasteHandler && this._pasteHandler.reset();
    },
    addFiles: function(a, b, c) {
        var d = [], e, f, g;
        if (a) {
            qq.isFileList(a) || (a = [].concat(a));
            for (e = 0; e < a.length; e += 1) if (f = a[e], qq.isFileOrInput(f)) if (qq.isInput(f) && qq.supportedFeatures.ajaxUploading) for (g = 0; g < f.files.length; g++) d.push(f.files[g]); else d.push(f); else this.log(f + " is not a File or INPUT element!  Ignoring!", "warn");
            this.log("Received " + d.length + " files or inputs.");
            this._prepareItemsForUpload(d, b, c);
        }
    },
    addBlobs: function(a, b, c) {
        if (a) {
            var a = [].concat(a), d = [], e = this;
            qq.each(a, function(a, b) {
                qq.isBlob(b) && !qq.isFileOrInput(b) ? d.push({
                    blob: b,
                    name: e._options.blobs.defaultName
                }) : qq.isObject(b) && b.blob && b.name ? d.push(b) : e.log("addBlobs: entry at index " + a + " is not a Blob or a BlobData object", "error");
            });
            this._prepareItemsForUpload(d, b, c);
        } else this.log("undefined or non-array parameter passed into addBlobs", "error");
    },
    getUuid: function(a) {
        return this._handler.getUuid(a);
    },
    getResumableFilesData: function() {
        return this._handler.getResumableFilesData();
    },
    getSize: function(a) {
        return this._handler.getSize(a);
    },
    getName: function(a) {
        return this._handler.getName(a);
    },
    getFile: function(a) {
        return this._handler.getFile(a);
    },
    deleteFile: function(a) {
        this._onSubmitDelete(a);
    },
    setDeleteFileEndpoint: function(a, b) {
        null == b ? this._options.deleteFile.endpoint = a : this._deleteFileEndpointStore.setEndpoint(a, b);
    },
    doesExist: function(a) {
        return this._handler.isValid(a);
    },
    getUploads: function(a) {
        return this._uploadData.retrieve(a);
    },
    _handleCheckedCallback: function(a) {
        var b = this, c = a.callback();
        if (qq.isPromise(c)) return this.log(a.name + " - waiting for " + a.name + " promise to be fulfilled for " + a.identifier), 
        c.then(function(c) {
            b.log(a.name + " promise success for " + a.identifier);
            a.onSuccess(c);
        }, function() {
            a.onFailure ? (b.log(a.name + " promise failure for " + a.identifier), a.onFailure()) : b.log(a.name + " promise failure for " + a.identifier);
        });
        if (!1 !== c) a.onSuccess(c); else a.onFailure ? (this.log(a.name + " - return value was 'false' for " + a.identifier + ".  Invoking failure callback."), 
        a.onFailure()) : this.log(a.name + " - return value was 'false' for " + a.identifier + ".  Will not proceed.");
        return c;
    },
    _createUploadButton: function(a) {
        var b = this, c = new qq.UploadButton({
            element: a,
            multiple: this._options.multiple && qq.supportedFeatures.ajaxUploading,
            acceptFiles: this._options.validation.acceptFiles,
            onChange: function(a) {
                b._onInputChange(a);
            },
            hoverClass: this._options.classes.buttonHover,
            focusClass: this._options.classes.buttonFocus
        });
        this._disposeSupport.addDisposer(function() {
            c.dispose();
        });
        return c;
    },
    _createUploadHandler: function() {
        var a = this;
        return new qq.UploadHandler({
            debug: this._options.debug,
            forceMultipart: this._options.request.forceMultipart,
            maxConnections: this._options.maxConnections,
            customHeaders: this._options.request.customHeaders,
            inputName: this._options.request.inputName,
            uuidParamName: this._options.request.uuidName,
            totalFileSizeParamName: this._options.request.totalFileSizeName,
            cors: this._options.cors,
            demoMode: this._options.demoMode,
            paramsInBody: this._options.request.paramsInBody,
            paramsStore: this._paramsStore,
            endpointStore: this._endpointStore,
            chunking: this._options.chunking,
            resume: this._options.resume,
            blobs: this._options.blobs,
            log: function(b, c) {
                a.log(b, c);
            },
            onProgress: function(b, c, d, e) {
                a._onProgress(b, c, d, e);
                a._options.callbacks.onProgress(b, c, d, e);
            },
            onComplete: function(b, c, d, e) {
                a._onComplete(b, c, d, e);
                a._options.callbacks.onComplete(b, c, d, e);
            },
            onCancel: function(b, c) {
                return a._handleCheckedCallback({
                    name: "onCancel",
                    callback: qq.bind(a._options.callbacks.onCancel, a, b, c),
                    onSuccess: qq.bind(a._onCancel, a, b, c),
                    identifier: b
                });
            },
            onUpload: function(b, c) {
                a._onUpload(b, c);
                a._options.callbacks.onUpload(b, c);
            },
            onUploadChunk: function(b, c, d) {
                a._options.callbacks.onUploadChunk(b, c, d);
            },
            onResume: function(b, c, d) {
                return a._options.callbacks.onResume(b, c, d);
            },
            onAutoRetry: function(b, c, d, e) {
                a._preventRetries[b] = d[a._options.retry.preventRetryResponseProperty];
                return a._shouldAutoRetry(b, c, d) ? (a._maybeParseAndSendUploadError(b, c, d, e), 
                a._options.callbacks.onAutoRetry(b, c, a._autoRetries[b] + 1), a._onBeforeAutoRetry(b, c), 
                a._retryTimeouts[b] = setTimeout(function() {
                    a._onAutoRetry(b, c, d);
                }, 1e3 * a._options.retry.autoAttemptDelay), !0) : !1;
            },
            onUuidChanged: function(b, c) {
                a._uploadData.uuidChanged(b, c);
            }
        });
    },
    _createDeleteHandler: function() {
        var a = this;
        return new qq.DeleteFileAjaxRequestor({
            maxConnections: this._options.maxConnections,
            customHeaders: this._options.deleteFile.customHeaders,
            paramsStore: this._deleteFileParamsStore,
            endpointStore: this._deleteFileEndpointStore,
            demoMode: this._options.demoMode,
            cors: this._options.cors,
            log: function(b, c) {
                a.log(b, c);
            },
            onDelete: function(b) {
                a._onDelete(b);
                a._options.callbacks.onDelete(b);
            },
            onDeleteComplete: function(b, c, d) {
                a._onDeleteComplete(b, c, d);
                a._options.callbacks.onDeleteComplete(b, c, d);
            }
        });
    },
    _createPasteHandler: function() {
        var a = this;
        return new qq.PasteSupport({
            targetElement: this._options.paste.targetElement,
            callbacks: {
                log: function(b, c) {
                    a.log(b, c);
                },
                pasteReceived: function(b) {
                    a._handleCheckedCallback({
                        name: "onPasteReceived",
                        callback: qq.bind(a._options.callbacks.onPasteReceived, a, b),
                        onSuccess: qq.bind(a._handlePasteSuccess, a, b),
                        identifier: "pasted image"
                    });
                }
            }
        });
    },
    _createUploadDataTracker: function() {
        var a = this;
        return new qq.UploadData({
            getName: function(b) {
                return a.getName(b);
            },
            getUuid: function(b) {
                return a.getUuid(b);
            },
            getSize: function(b) {
                return a.getSize(b);
            },
            onStatusChange: function(b, c, d) {
                a._options.callbacks.onStatusChange(b, c, d);
            }
        });
    },
    _handlePasteSuccess: function(a, b) {
        var c = a.type.split("/")[1], d = b;
        null == d && (d = this._options.paste.defaultName);
        this.addBlobs({
            name: d + ("." + c),
            blob: a
        });
    },
    _preventLeaveInProgress: function() {
        var a = this;
        this._disposeSupport.attach(window, "beforeunload", function(b) {
            if (a._filesInProgress.length) return b = b || window.event, b.returnValue = a._options.messages.onLeave;
        });
    },
    _onSubmit: function(a) {
        this._netUploadedOrQueued++;
        this._options.autoUpload && this._filesInProgress.push(a);
    },
    _onProgress: function() {},
    _onComplete: function(a, b, c, d) {
        c.success ? (this._uploadData.setStatus(a, qq.status.UPLOAD_SUCCESSFUL), this._netUploaded++) : (this._uploadData.setStatus(a, qq.status.UPLOAD_FAILED), 
        this._netUploadedOrQueued--);
        this._removeFromFilesInProgress(a);
        this._maybeParseAndSendUploadError(a, b, c, d);
    },
    _onCancel: function(a) {
        this._uploadData.setStatus(a, qq.status.CANCELED);
        this._netUploadedOrQueued--;
        this._removeFromFilesInProgress(a);
        clearTimeout(this._retryTimeouts[a]);
        a = qq.indexOf(this._storedIds, a);
        !this._options.autoUpload && 0 <= a && this._storedIds.splice(a, 1);
    },
    _isDeletePossible: function() {
        return this._options.deleteFile.enabled && (!this._options.cors.expected || qq.supportedFeatures.deleteFileCors);
    },
    _onSubmitDelete: function(a, b) {
        if (this._isDeletePossible()) return this._handleCheckedCallback({
            name: "onSubmitDelete",
            callback: qq.bind(this._options.callbacks.onSubmitDelete, this, a),
            onSuccess: b || qq.bind(this._deleteHandler.sendDelete, this, a, this.getUuid(a)),
            identifier: a
        });
        this.log("Delete request ignored for ID " + a + ", delete feature is disabled or request not possible due to CORS on a user agent that does not support pre-flighting.", "warn");
        return !1;
    },
    _onDelete: function(a) {
        this._uploadData.setStatus(a, qq.status.DELETING);
    },
    _onDeleteComplete: function(a, b, c) {
        var d = this._handler.getName(a);
        c ? (this._uploadData.setStatus(a, qq.status.DELETE_FAILED), this.log("Delete request for '" + d + "' has failed.", "error"), 
        this._options.callbacks.onError(a, d, "Delete request failed with response code " + b.status, b)) : (this._uploadData.setStatus(a, qq.status.DELETED), 
        this._netUploadedOrQueued--, this._netUploaded--, this._handler.expunge(a), this.log("Delete request for '" + d + "' has succeeded."));
    },
    _removeFromFilesInProgress: function(a) {
        a = qq.indexOf(this._filesInProgress, a);
        0 <= a && this._filesInProgress.splice(a, 1);
    },
    _onUpload: function(a) {
        this._uploadData.setStatus(a, qq.status.UPLOADING);
    },
    _onInputChange: function(a) {
        qq.supportedFeatures.ajaxUploading ? this.addFiles(a.files) : this.addFiles(a);
        this._button.reset();
    },
    _onBeforeAutoRetry: function(a, b) {
        this.log("Waiting " + this._options.retry.autoAttemptDelay + " seconds before retrying " + b + "...");
    },
    _onAutoRetry: function(a, b) {
        this.log("Retrying " + b + "...");
        this._autoRetries[a]++;
        this._uploadData.setStatus(a, qq.status.UPLOAD_RETRYING);
        this._handler.retry(a);
    },
    _shouldAutoRetry: function(a) {
        return !this._preventRetries[a] && this._options.retry.enableAuto ? (void 0 === this._autoRetries[a] && (this._autoRetries[a] = 0), 
        this._autoRetries[a] < this._options.retry.maxAutoAttempts) : !1;
    },
    _onBeforeManualRetry: function(a) {
        var b = this._options.validation.itemLimit;
        if (this._preventRetries[a]) return this.log("Retries are forbidden for id " + a, "warn"), 
        !1;
        if (this._handler.isValid(a)) {
            var c = this._handler.getName(a);
            if (!1 === this._options.callbacks.onManualRetry(a, c)) return !1;
            if (0 < b && this._netUploadedOrQueued + 1 > b) return this._itemError("retryFailTooManyItems", ""), 
            !1;
            this.log("Retrying upload for '" + c + "' (id: " + a + ")...");
            this._filesInProgress.push(a);
            return !0;
        }
        this.log("'" + a + "' is not a valid file ID", "error");
        return !1;
    },
    _maybeParseAndSendUploadError: function(a, b, c, d) {
        if (!c.success) if (d && 200 !== d.status && !c.error) this._options.callbacks.onError(a, b, "XHR returned response code " + d.status, d); else this._options.callbacks.onError(a, b, c.error ? c.error : this._options.text.defaultResponseError, d);
    },
    _prepareItemsForUpload: function(a, b, c) {
        var d = this._getValidationDescriptors(a);
        this._handleCheckedCallback({
            name: "onValidateBatch",
            callback: qq.bind(this._options.callbacks.onValidateBatch, this, d),
            onSuccess: qq.bind(this._onValidateBatchCallbackSuccess, this, d, a, b, c),
            identifier: "batch validation"
        });
    },
    _upload: function(a, b, c) {
        var a = this._handler.add(a), d = this._handler.getName(a);
        this._uploadData.added(a);
        b && this.setParams(b, a);
        c && this.setEndpoint(c, a);
        this._handleCheckedCallback({
            name: "onSubmit",
            callback: qq.bind(this._options.callbacks.onSubmit, this, a, d),
            onSuccess: qq.bind(this._onSubmitCallbackSuccess, this, a, d),
            onFailure: qq.bind(this._fileOrBlobRejected, this, a, d),
            identifier: a
        });
    },
    _onSubmitCallbackSuccess: function(a, b) {
        this._uploadData.setStatus(a, qq.status.SUBMITTED);
        this._onSubmit(a, b);
        this._options.callbacks.onSubmitted(a, b);
        this._options.autoUpload ? this._handler.upload(a) || this._uploadData.setStatus(a, qq.status.QUEUED) : this._storeForLater(a);
    },
    _storeForLater: function(a) {
        this._storedIds.push(a);
    },
    _onValidateBatchCallbackSuccess: function(a, b, c, d) {
        var e = this._options.validation.itemLimit, a = this._netUploadedOrQueued + a.length;
        0 === e || a <= e ? 0 < b.length ? this._handleCheckedCallback({
            name: "onValidate",
            callback: qq.bind(this._options.callbacks.onValidate, this, b[0]),
            onSuccess: qq.bind(this._onValidateCallbackSuccess, this, b, 0, c, d),
            onFailure: qq.bind(this._onValidateCallbackFailure, this, b, 0, c, d),
            identifier: "Item '" + b[0].name + "', size: " + b[0].size
        }) : this._itemError("noFilesError", "") : (b = this._options.messages.tooManyItemsError.replace(/\{netItems\}/g, a).replace(/\{itemLimit\}/g, e), 
        this._batchError(b));
    },
    _onValidateCallbackSuccess: function(a, b, c, d) {
        var e = b + 1, f = this._getValidationDescriptor(a[b]), g = !1;
        this._validateFileOrBlobData(a[b], f) && (g = !0, this._upload(a[b], c, d));
        this._maybeProcessNextItemAfterOnValidateCallback(g, a, e, c, d);
    },
    _onValidateCallbackFailure: function(a, b, c, d) {
        b += 1;
        this._fileOrBlobRejected(void 0, a[0].name);
        this._maybeProcessNextItemAfterOnValidateCallback(!1, a, b, c, d);
    },
    _maybeProcessNextItemAfterOnValidateCallback: function(a, b, c, d, e) {
        var f = this;
        b.length > c && (a || !this._options.validation.stopOnFirstInvalidFile) && setTimeout(function() {
            var a = f._getValidationDescriptor(b[c]);
            f._handleCheckedCallback({
                name: "onValidate",
                callback: qq.bind(f._options.callbacks.onValidate, f, b[c]),
                onSuccess: qq.bind(f._onValidateCallbackSuccess, f, b, c, d, e),
                onFailure: qq.bind(f._onValidateCallbackFailure, f, b, c, d, e),
                identifier: "Item '" + a.name + "', size: " + a.size
            });
        }, 0);
    },
    _validateFileOrBlobData: function(a, b) {
        var c = b.name, d = b.size, e = !0;
        !1 === this._options.callbacks.onValidate(b) && (e = !1);
        qq.isFileOrInput(a) && !this._isAllowedExtension(c) ? (this._itemError("typeError", c), 
        e = !1) : 0 === d ? (this._itemError("emptyError", c), e = !1) : d && this._options.validation.sizeLimit && d > this._options.validation.sizeLimit ? (this._itemError("sizeError", c), 
        e = !1) : d && d < this._options.validation.minSizeLimit && (this._itemError("minSizeError", c), 
        e = !1);
        e || this._fileOrBlobRejected(void 0, c);
        return e;
    },
    _fileOrBlobRejected: function(a) {
        void 0 !== a && this._uploadData.setStatus(a, qq.status.REJECTED);
    },
    _itemError: function(a, b) {
        function c(a, b) {
            d = d.replace(a, b);
        }
        var d = this._options.messages[a], e = [], f = [].concat(b), g = f[0], i;
        qq.each(this._options.validation.allowedExtensions, function(a, b) {
            qq.isString(b) && e.push(b);
        });
        i = e.join(", ").toLowerCase();
        c("{file}", this._options.formatFileName(g));
        c("{extensions}", i);
        c("{sizeLimit}", this._formatSize(this._options.validation.sizeLimit));
        c("{minSizeLimit}", this._formatSize(this._options.validation.minSizeLimit));
        i = d.match(/(\{\w+\})/g);
        null !== i && qq.each(i, function(a, b) {
            c(b, f[a]);
        });
        this._options.callbacks.onError(null, g, d, void 0);
        return d;
    },
    _batchError: function(a) {
        this._options.callbacks.onError(null, null, a, void 0);
    },
    _isAllowedExtension: function(a) {
        var b = this._options.validation.allowedExtensions, c = !1;
        if (!b.length) return !0;
        qq.each(b, function(b, e) {
            if (qq.isString(e) && null != a.match(RegExp("\\." + e + "$", "i"))) return c = !0, 
            !1;
        });
        return c;
    },
    _formatSize: function(a) {
        var b = -1;
        do a /= 1e3, b++; while (999 < a);
        return Math.max(a, .1).toFixed(1) + this._options.text.sizeSymbols[b];
    },
    _wrapCallbacks: function() {
        var a, b;
        a = this;
        b = function(b, c, f) {
            try {
                return c.apply(a, f);
            } catch (g) {
                a.log("Caught exception in '" + b + "' callback - " + g.message, "error");
            }
        };
        for (var c in this._options.callbacks) (function() {
            var d, e;
            d = c;
            e = a._options.callbacks[d];
            a._options.callbacks[d] = function() {
                return b(d, e, arguments);
            };
        })();
    },
    _parseFileOrBlobDataName: function(a) {
        return qq.isFileOrInput(a) ? a.value ? a.value.replace(/.*(\/|\\)/, "") : null !== a.fileName && void 0 !== a.fileName ? a.fileName : a.name : a.name;
    },
    _parseFileOrBlobDataSize: function(a) {
        var b;
        qq.isFileOrInput(a) ? a.value || (b = null !== a.fileSize && void 0 !== a.fileSize ? a.fileSize : a.size) : b = a.blob.size;
        return b;
    },
    _getValidationDescriptor: function(a) {
        var b, c;
        c = {};
        b = this._parseFileOrBlobDataName(a);
        a = this._parseFileOrBlobDataSize(a);
        c.name = b;
        void 0 !== a && (c.size = a);
        return c;
    },
    _getValidationDescriptors: function(a) {
        var b = this, c = [];
        qq.each(a, function(a, e) {
            c.push(b._getValidationDescriptor(e));
        });
        return c;
    },
    _createParamsStore: function(a) {
        var b = {}, c = this;
        return {
            setParams: function(a, c) {
                var f = {};
                qq.extend(f, a);
                b[c] = f;
            },
            getParams: function(d) {
                var e = {};
                null != d && b[d] ? qq.extend(e, b[d]) : qq.extend(e, c._options[a].params);
                return e;
            },
            remove: function(a) {
                return delete b[a];
            },
            reset: function() {
                b = {};
            }
        };
    },
    _createEndpointStore: function(a) {
        var b = {}, c = this;
        return {
            setEndpoint: function(a, c) {
                b[c] = a;
            },
            getEndpoint: function(d) {
                return null != d && b[d] ? b[d] : c._options[a].endpoint;
            },
            remove: function(a) {
                return delete b[a];
            },
            reset: function() {
                b = {};
            }
        };
    },
    _handleCameraAccess: function() {
        this._options.camera.ios && qq.ios() && (this._options.multiple = !1, this._options.validation.acceptFiles = null === this._options.validation.acceptFiles ? "image/*;capture=camera" : this._options.validation.acceptFiles + ",image/*;capture=camera");
    }
};

qq.DragAndDrop = function(a) {
    function b(a) {
        var c, d, e = new qq.Promise();
        a.isFile ? a.file(function(a) {
            i.push(a);
            e.success();
        }, function(b) {
            f.callbacks.dropLog("Problem parsing '" + a.fullPath + "'.  FileError code " + b.code + ".", "error");
            e.failure();
        }) : a.isDirectory && (c = a.createReader(), c.readEntries(function(a) {
            var c = a.length;
            for (d = 0; d < a.length; d += 1) b(a[d]).done(function() {
                c = c - 1;
                c === 0 && e.success();
            });
            a.length || e.success();
        }, function(b) {
            f.callbacks.dropLog("Problem parsing '" + a.fullPath + "'.  FileError code " + b.code + ".", "error");
            e.failure();
        }));
        return e;
    }
    function c(a) {
        var c, d, e = [], j = new qq.Promise();
        f.callbacks.processingDroppedFiles();
        g.dropDisabled(!0);
        if (1 < a.files.length && !f.allowMultipleItems) f.callbacks.processingDroppedFilesComplete([]), 
        f.callbacks.dropError("tooManyFilesError", ""), g.dropDisabled(!1), j.failure(); else {
            i = [];
            if (qq.isFolderDropSupported(a)) {
                c = a.items;
                for (a = 0; a < c.length; a += 1) (d = c[a].webkitGetAsEntry()) && (d.isFile ? i.push(c[a].getAsFile()) : e.push(b(d).done(function() {
                    e.pop();
                    e.length === 0 && j.success();
                })));
            } else i = a.files;
            0 === e.length && j.success();
        }
        return j;
    }
    function d(a) {
        g = new qq.UploadDropZone({
            element: a,
            onEnter: function(b) {
                qq(a).addClass(f.classes.dropActive);
                b.stopPropagation();
            },
            onLeaveNotDescendants: function() {
                qq(a).removeClass(f.classes.dropActive);
            },
            onDrop: function(b) {
                f.hideDropZonesBeforeEnter && qq(a).hide();
                qq(a).removeClass(f.classes.dropActive);
                c(b.dataTransfer).done(function() {
                    var a = i;
                    f.callbacks.dropLog("Grabbed " + a.length + " dropped files.");
                    g.dropDisabled(!1);
                    f.callbacks.processingDroppedFilesComplete(a);
                });
            }
        });
        j.addDisposer(function() {
            g.dispose();
        });
        f.hideDropZonesBeforeEnter && qq(a).hide();
    }
    function e(a) {
        var b;
        qq.each(a.dataTransfer.types, function(a, c) {
            if ("Files" === c) return b = !0, !1;
        });
        return b;
    }
    var f, g, i = [], j = new qq.DisposeSupport();
    f = {
        dropZoneElements: [],
        hideDropZonesBeforeEnter: !1,
        allowMultipleItems: !0,
        classes: {
            dropActive: null
        },
        callbacks: new qq.DragAndDrop.callbacks()
    };
    qq.extend(f, a, !0);
    (function() {
        var a = f.dropZoneElements;
        qq.each(a, function(a, b) {
            d(b);
        });
        a.length && (!qq.ie() || qq.ie10()) && j.attach(document, "dragenter", function(b) {
            !g.dropDisabled() && e(b) && qq.each(a, function(a, b) {
                qq(b).css({
                    display: "block"
                });
            });
        });
        j.attach(document, "dragleave", function(b) {
            f.hideDropZonesBeforeEnter && qq.FineUploader.prototype._leaving_document_out(b) && qq.each(a, function(a, b) {
                qq(b).hide();
            });
        });
        j.attach(document, "drop", function(b) {
            f.hideDropZonesBeforeEnter && qq.each(a, function(a, b) {
                qq(b).hide();
            });
            b.preventDefault();
        });
    })();
    return {
        setupExtraDropzone: function(a) {
            f.dropZoneElements.push(a);
            d(a);
        },
        removeDropzone: function(a) {
            var b, c = f.dropZoneElements;
            for (b in c) if (c[b] === a) return c.splice(b, 1);
        },
        dispose: function() {
            j.dispose();
            g.dispose();
        }
    };
};

qq.DragAndDrop.callbacks = function() {
    return {
        processingDroppedFiles: function() {},
        processingDroppedFilesComplete: function() {},
        dropError: function(a, b) {
            qq.log("Drag & drop error code '" + a + " with these specifics: '" + b + "'", "error");
        },
        dropLog: function(a, b) {
            qq.log(a, b);
        }
    };
};

qq.UploadDropZone = function(a) {
    function b() {
        return qq.safari() || qq.firefox() && qq.windows();
    }
    function c(a) {
        if (qq.ie() && !qq.ie10()) return !1;
        var b = a.dataTransfer, c = qq.safari(), a = qq.ie10() ? !0 : "none" !== b.effectAllowed;
        return b && a && (b.files || !c && b.types.contains && b.types.contains("Files"));
    }
    function d(a) {
        void 0 !== a && (g = a);
        return g;
    }
    var e, f, g, i, j = new qq.DisposeSupport();
    e = {
        element: null,
        onEnter: function() {},
        onLeave: function() {},
        onLeaveNotDescendants: function() {},
        onDrop: function() {}
    };
    qq.extend(e, a);
    f = e.element;
    (function() {
        i || (b ? j.attach(document, "dragover", function(a) {
            a.preventDefault();
        }) : j.attach(document, "dragover", function(a) {
            a.dataTransfer && (a.dataTransfer.dropEffect = "none", a.preventDefault());
        }), i = !0);
    })();
    (function() {
        j.attach(f, "dragover", function(a) {
            if (c(a)) {
                var b = qq.ie() ? null : a.dataTransfer.effectAllowed;
                a.dataTransfer.dropEffect = "move" === b || "linkMove" === b ? "move" : "copy";
                a.stopPropagation();
                a.preventDefault();
            }
        });
        j.attach(f, "dragenter", function(a) {
            if (!d() && c(a)) e.onEnter(a);
        });
        j.attach(f, "dragleave", function(a) {
            if (c(a)) {
                e.onLeave(a);
                var b = document.elementFromPoint(a.clientX, a.clientY);
                if (!qq(this).contains(b)) e.onLeaveNotDescendants(a);
            }
        });
        j.attach(f, "drop", function(a) {
            !d() && c(a) && (a.preventDefault(), e.onDrop(a));
        });
    })();
    return {
        dropDisabled: function(a) {
            return d(a);
        },
        dispose: function() {
            j.dispose();
        }
    };
};

qq.FineUploader = function(a) {
    qq.FineUploaderBasic.apply(this, arguments);
    qq.extend(this._options, {
        element: null,
        listElement: null,
        dragAndDrop: {
            extraDropzones: [],
            hideDropzones: !0,
            disableDefaultDropzone: !1
        },
        text: {
            uploadButton: "Upload a file",
            cancelButton: "Cancel",
            retryButton: "Retry",
            deleteButton: "Delete",
            failUpload: "Upload failed",
            dragZone: "Drop files here to upload",
            dropProcessing: "Processing dropped files...",
            formatProgress: "{percent}% of {total_size}",
            waitingForResponse: "Processing..."
        },
        template: '<div class="qq-uploader">' + (!this._options.dragAndDrop || !this._options.dragAndDrop.disableDefaultDropzone ? '<div class="qq-upload-drop-area"><span>{dragZoneText}</span></div>' : "") + (!this._options.button ? '<div class="qq-upload-button"><div>{uploadButtonText}</div></div>' : "") + '<span class="qq-drop-processing"><span>{dropProcessingText}</span><span class="qq-drop-processing-spinner"></span></span>' + (!this._options.listElement ? '<ul class="qq-upload-list"></ul>' : "") + "</div>",
        fileTemplate: '<li><div class="qq-progress-bar"></div><span class="qq-upload-spinner"></span><span class="qq-upload-finished"></span><span class="qq-upload-file"></span><span class="qq-upload-size"></span><a class="qq-upload-cancel" href="#">{cancelButtonText}</a><a class="qq-upload-retry" href="#">{retryButtonText}</a><a class="qq-upload-delete" href="#">{deleteButtonText}</a><span class="qq-upload-status-text">{statusText}</span></li>',
        classes: {
            button: "qq-upload-button",
            drop: "qq-upload-drop-area",
            dropActive: "qq-upload-drop-area-active",
            list: "qq-upload-list",
            progressBar: "qq-progress-bar",
            file: "qq-upload-file",
            spinner: "qq-upload-spinner",
            finished: "qq-upload-finished",
            retrying: "qq-upload-retrying",
            retryable: "qq-upload-retryable",
            size: "qq-upload-size",
            cancel: "qq-upload-cancel",
            deleteButton: "qq-upload-delete",
            retry: "qq-upload-retry",
            statusText: "qq-upload-status-text",
            success: "qq-upload-success",
            fail: "qq-upload-fail",
            successIcon: null,
            failIcon: null,
            dropProcessing: "qq-drop-processing",
            dropProcessingSpinner: "qq-drop-processing-spinner"
        },
        failedUploadTextDisplay: {
            mode: "default",
            maxChars: 50,
            responseProperty: "error",
            enableTooltip: !0
        },
        messages: {
            tooManyFilesError: "You may only drop one file",
            unsupportedBrowser: "Unrecoverable error - this browser does not permit file uploading of any kind."
        },
        retry: {
            showAutoRetryNote: !0,
            autoRetryNote: "Retrying {retryNum}/{maxAuto}...",
            showButton: !1
        },
        deleteFile: {
            forceConfirm: !1,
            confirmMessage: "Are you sure you want to delete {filename}?",
            deletingStatusText: "Deleting...",
            deletingFailedText: "Delete failed"
        },
        display: {
            fileSizeOnSubmit: !1,
            prependFiles: !1
        },
        paste: {
            promptForName: !1,
            namePromptMessage: "Please name this image"
        },
        showMessage: function(a) {
            setTimeout(function() {
                window.alert(a);
            }, 0);
        },
        showConfirm: function(a, c, d) {
            setTimeout(function() {
                window.confirm(a) ? c() : d && d();
            }, 0);
        },
        showPrompt: function(a, c) {
            var d = new qq.Promise(), e = window.prompt(a, c);
            null != e && 0 < qq.trimStr(e).length ? d.success(e) : d.failure("Undefined or invalid user-supplied value.");
            return d;
        }
    }, !0);
    qq.extend(this._options, a, !0);
    !qq.supportedFeatures.uploading || this._options.cors.expected && !qq.supportedFeatures.uploadCors ? this._options.element.innerHTML = "<div>" + this._options.messages.unsupportedBrowser + "</div>" : (this._wrapCallbacks(), 
    this._options.template = this._options.template.replace(/\{dragZoneText\}/g, this._options.text.dragZone), 
    this._options.template = this._options.template.replace(/\{uploadButtonText\}/g, this._options.text.uploadButton), 
    this._options.template = this._options.template.replace(/\{dropProcessingText\}/g, this._options.text.dropProcessing), 
    this._options.fileTemplate = this._options.fileTemplate.replace(/\{cancelButtonText\}/g, this._options.text.cancelButton), 
    this._options.fileTemplate = this._options.fileTemplate.replace(/\{retryButtonText\}/g, this._options.text.retryButton), 
    this._options.fileTemplate = this._options.fileTemplate.replace(/\{deleteButtonText\}/g, this._options.text.deleteButton), 
    this._options.fileTemplate = this._options.fileTemplate.replace(/\{statusText\}/g, ""), 
    this._element = this._options.element, this._element.innerHTML = this._options.template, 
    this._listElement = this._options.listElement || this._find(this._element, "list"), 
    this._classes = this._options.classes, this._button || (this._button = this._createUploadButton(this._find(this._element, "button"))), 
    this._bindCancelAndRetryEvents(), this._dnd = this._setupDragAndDrop(), this._options.paste.targetElement && this._options.paste.promptForName && this._setupPastePrompt(), 
    this._filesInBatchAddedToUi = this._totalFilesInBatch = 0);
};

qq.extend(qq.FineUploader.prototype, qq.FineUploaderBasic.prototype);

qq.extend(qq.FineUploader.prototype, {
    clearStoredFiles: function() {
        qq.FineUploaderBasic.prototype.clearStoredFiles.apply(this, arguments);
        this._listElement.innerHTML = "";
    },
    addExtraDropzone: function(a) {
        this._dnd.setupExtraDropzone(a);
    },
    removeExtraDropzone: function(a) {
        return this._dnd.removeDropzone(a);
    },
    getItemByFileId: function(a) {
        for (var b = this._listElement.firstChild; b; ) {
            if (b.qqFileId == a) return b;
            b = b.nextSibling;
        }
    },
    reset: function() {
        qq.FineUploaderBasic.prototype.reset.apply(this, arguments);
        this._element.innerHTML = this._options.template;
        this._listElement = this._options.listElement || this._find(this._element, "list");
        this._options.button || (this._button = this._createUploadButton(this._find(this._element, "button")));
        this._bindCancelAndRetryEvents();
        this._dnd.dispose();
        this._dnd = this._setupDragAndDrop();
        this._filesInBatchAddedToUi = this._totalFilesInBatch = 0;
    },
    _removeFileItem: function(a) {
        a = this.getItemByFileId(a);
        qq(a).remove();
    },
    _setupDragAndDrop: function() {
        var a = this, b = this._find(this._element, "dropProcessing"), c = this._options.dragAndDrop.extraDropzones, d;
        d = function(a) {
            a.preventDefault();
        };
        this._options.dragAndDrop.disableDefaultDropzone || c.push(this._find(this._options.element, "drop"));
        return new qq.DragAndDrop({
            dropZoneElements: c,
            hideDropZonesBeforeEnter: this._options.dragAndDrop.hideDropzones,
            allowMultipleItems: this._options.multiple,
            classes: {
                dropActive: this._options.classes.dropActive
            },
            callbacks: {
                processingDroppedFiles: function() {
                    var c = a._button.getInput();
                    qq(b).css({
                        display: "block"
                    });
                    qq(c).attach("click", d);
                },
                processingDroppedFilesComplete: function(c) {
                    var f = a._button.getInput();
                    qq(b).hide();
                    qq(f).detach("click", d);
                    c && a.addFiles(c);
                },
                dropError: function(b, c) {
                    a._itemError(b, c);
                },
                dropLog: function(b, c) {
                    a.log(b, c);
                }
            }
        });
    },
    _leaving_document_out: function(a) {
        return (qq.chrome() || qq.safari() && qq.windows()) && 0 == a.clientX && 0 == a.clientY || qq.firefox() && !a.relatedTarget;
    },
    _storeForLater: function(a) {
        qq.FineUploaderBasic.prototype._storeForLater.apply(this, arguments);
        var b = this.getItemByFileId(a);
        qq(this._find(b, "spinner")).hide();
    },
    _find: function(a, b) {
        var c = qq(a).getByClass(this._options.classes[b])[0];
        if (!c) throw Error("element not found " + b);
        return c;
    },
    _onSubmit: function(a, b) {
        qq.FineUploaderBasic.prototype._onSubmit.apply(this, arguments);
        this._addToList(a, b);
    },
    _onProgress: function(a, b, c, d) {
        qq.FineUploaderBasic.prototype._onProgress.apply(this, arguments);
        var e, f, g, i;
        e = this.getItemByFileId(a);
        f = this._find(e, "progressBar");
        g = Math.round(100 * (c / d));
        c === d ? (i = this._find(e, "cancel"), qq(i).hide(), qq(f).hide(), qq(this._find(e, "statusText")).setText(this._options.text.waitingForResponse), 
        this._displayFileSize(a)) : (this._displayFileSize(a, c, d), qq(f).css({
            display: "block"
        }));
        qq(f).css({
            width: g + "%"
        });
    },
    _onComplete: function(a, b, c, d) {
        qq.FineUploaderBasic.prototype._onComplete.apply(this, arguments);
        var e = this.getItemByFileId(a);
        qq(this._find(e, "statusText")).clearText();
        qq(e).removeClass(this._classes.retrying);
        qq(this._find(e, "progressBar")).hide();
        (!this._options.disableCancelForFormUploads || qq.supportedFeatures.ajaxUploading) && qq(this._find(e, "cancel")).hide();
        qq(this._find(e, "spinner")).hide();
        c.success ? (this._isDeletePossible() && this._showDeleteLink(a), qq(e).addClass(this._classes.success), 
        this._classes.successIcon && (this._find(e, "finished").style.display = "inline-block", 
        qq(e).addClass(this._classes.successIcon))) : (qq(e).addClass(this._classes.fail), 
        this._classes.failIcon && (this._find(e, "finished").style.display = "inline-block", 
        qq(e).addClass(this._classes.failIcon)), this._options.retry.showButton && !this._preventRetries[a] && qq(e).addClass(this._classes.retryable), 
        this._controlFailureTextDisplay(e, c));
    },
    _onUpload: function(a, b) {
        qq.FineUploaderBasic.prototype._onUpload.apply(this, arguments);
        this._showSpinner(a);
    },
    _onCancel: function(a, b) {
        qq.FineUploaderBasic.prototype._onCancel.apply(this, arguments);
        this._removeFileItem(a);
    },
    _onBeforeAutoRetry: function(a) {
        var b, c, d, e, f;
        qq.FineUploaderBasic.prototype._onBeforeAutoRetry.apply(this, arguments);
        b = this.getItemByFileId(a);
        c = this._find(b, "progressBar");
        this._showCancelLink(b);
        c.style.width = 0;
        qq(c).hide();
        this._options.retry.showAutoRetryNote && (c = this._find(b, "statusText"), d = this._autoRetries[a] + 1, 
        e = this._options.retry.maxAutoAttempts, f = this._options.retry.autoRetryNote.replace(/\{retryNum\}/g, d), 
        f = f.replace(/\{maxAuto\}/g, e), qq(c).setText(f), 1 === d && qq(b).addClass(this._classes.retrying));
    },
    _onBeforeManualRetry: function(a) {
        var b = this.getItemByFileId(a);
        if (qq.FineUploaderBasic.prototype._onBeforeManualRetry.apply(this, arguments)) return this._find(b, "progressBar").style.width = 0, 
        qq(b).removeClass(this._classes.fail), qq(this._find(b, "statusText")).clearText(), 
        this._showSpinner(a), this._showCancelLink(b), !0;
        qq(b).addClass(this._classes.retryable);
        return !1;
    },
    _onSubmitDelete: function(a) {
        var b = qq.bind(this._onSubmitDeleteSuccess, this, a);
        qq.FineUploaderBasic.prototype._onSubmitDelete.call(this, a, b);
    },
    _onSubmitDeleteSuccess: function(a) {
        this._options.deleteFile.forceConfirm ? this._showDeleteConfirm(a) : this._sendDeleteRequest(a);
    },
    _onDeleteComplete: function(a, b, c) {
        qq.FineUploaderBasic.prototype._onDeleteComplete.apply(this, arguments);
        var d = this.getItemByFileId(a), e = this._find(d, "spinner"), d = this._find(d, "statusText");
        qq(e).hide();
        c ? (qq(d).setText(this._options.deleteFile.deletingFailedText), this._showDeleteLink(a)) : this._removeFileItem(a);
    },
    _sendDeleteRequest: function(a) {
        var b = this.getItemByFileId(a), c = this._find(b, "deleteButton"), b = this._find(b, "statusText");
        qq(c).hide();
        this._showSpinner(a);
        qq(b).setText(this._options.deleteFile.deletingStatusText);
        this._deleteHandler.sendDelete(a, this.getUuid(a));
    },
    _showDeleteConfirm: function(a) {
        var b = this._options.deleteFile.confirmMessage.replace(/\{filename\}/g, this._handler.getName(a));
        this.getUuid(a);
        var c = this;
        this._options.showConfirm(b, function() {
            c._sendDeleteRequest(a);
        });
    },
    _addToList: function(a, b) {
        var c = qq.toElement(this._options.fileTemplate);
        if (this._options.disableCancelForFormUploads && !qq.supportedFeatures.ajaxUploading) {
            var d = this._find(c, "cancel");
            qq(d).remove();
        }
        c.qqFileId = a;
        d = this._find(c, "file");
        qq(d).setText(this._options.formatFileName(b));
        qq(this._find(c, "size")).hide();
        this._options.multiple || (this._handler.cancelAll(), this._clearList());
        this._options.display.prependFiles ? this._prependItem(c) : this._listElement.appendChild(c);
        this._filesInBatchAddedToUi += 1;
        this._options.display.fileSizeOnSubmit && qq.supportedFeatures.ajaxUploading && this._displayFileSize(a);
    },
    _prependItem: function(a) {
        var b = this._listElement, c = b.firstChild;
        1 < this._totalFilesInBatch && 0 < this._filesInBatchAddedToUi && (c = qq(b).children()[this._filesInBatchAddedToUi - 1].nextSibling);
        b.insertBefore(a, c);
    },
    _clearList: function() {
        this._listElement.innerHTML = "";
        this.clearStoredFiles();
    },
    _displayFileSize: function(a, b, c) {
        var d = this.getItemByFileId(a), a = this._formatSize(this.getSize(a)), d = this._find(d, "size");
        void 0 !== b && void 0 !== c && (a = this._formatProgress(b, c));
        qq(d).css({
            display: "inline"
        });
        qq(d).setText(a);
    },
    _bindCancelAndRetryEvents: function() {
        var a = this;
        this._disposeSupport.attach(this._listElement, "click", function(b) {
            var b = b || window.event, c = b.target || b.srcElement;
            if (qq(c).hasClass(a._classes.cancel) || qq(c).hasClass(a._classes.retry) || qq(c).hasClass(a._classes.deleteButton)) {
                qq.preventDefault(b);
                for (b = c.parentNode; void 0 === b.qqFileId; ) b = b.parentNode;
                qq(c).hasClass(a._classes.deleteButton) ? a.deleteFile(b.qqFileId) : qq(c).hasClass(a._classes.cancel) ? a.cancel(b.qqFileId) : (qq(b).removeClass(a._classes.retryable), 
                a.retry(b.qqFileId));
            }
        });
    },
    _formatProgress: function(a, b) {
        var c = this._options.text.formatProgress, d = Math.round(100 * (a / b)), c = c.replace("{percent}", d), d = this._formatSize(b);
        return c = c.replace("{total_size}", d);
    },
    _controlFailureTextDisplay: function(a, b) {
        var c, d, e, f;
        c = this._options.failedUploadTextDisplay.mode;
        d = this._options.failedUploadTextDisplay.maxChars;
        e = this._options.failedUploadTextDisplay.responseProperty;
        "custom" === c ? ((c = b[e]) ? c.length > d && (f = c.substring(0, d) + "...") : (c = this._options.text.failUpload, 
        this.log("'" + e + "' is not a valid property on the server response.", "warn")), 
        qq(this._find(a, "statusText")).setText(f || c), this._options.failedUploadTextDisplay.enableTooltip && this._showTooltip(a, c)) : "default" === c ? qq(this._find(a, "statusText")).setText(this._options.text.failUpload) : "none" !== c && this.log("failedUploadTextDisplay.mode value of '" + c + "' is not valid", "warn");
    },
    _showTooltip: function(a, b) {
        a.title = b;
    },
    _showSpinner: function(a) {
        this._find(this.getItemByFileId(a), "spinner").style.display = "inline-block";
    },
    _showCancelLink: function(a) {
        if (!this._options.disableCancelForFormUploads || qq.supportedFeatures.ajaxUploading) a = this._find(a, "cancel"), 
        qq(a).css({
            display: "inline"
        });
    },
    _showDeleteLink: function(a) {
        a = this._find(this.getItemByFileId(a), "deleteButton");
        qq(a).css({
            display: "inline"
        });
    },
    _itemError: function(a, b) {
        this._options.showMessage(qq.FineUploaderBasic.prototype._itemError.apply(this, arguments));
    },
    _batchError: function(a) {
        qq.FineUploaderBasic.prototype._batchError.apply(this, arguments);
        this._options.showMessage(a);
    },
    _setupPastePrompt: function() {
        var a = this;
        this._options.callbacks.onPasteReceived = function() {
            return a._options.showPrompt(a._options.paste.namePromptMessage, a._options.paste.defaultName);
        };
    },
    _fileOrBlobRejected: function(a, b) {
        this._totalFilesInBatch -= 1;
        qq.FineUploaderBasic.prototype._fileOrBlobRejected.apply(this, arguments);
    },
    _prepareItemsForUpload: function(a, b, c) {
        this._totalFilesInBatch = a.length;
        this._filesInBatchAddedToUi = 0;
        qq.FineUploaderBasic.prototype._prepareItemsForUpload.apply(this, arguments);
    }
});

qq.AjaxRequestor = function(a) {
    function b(a) {
        var b = qq.indexOf(j, a), d = l.maxConnections;
        delete s[a];
        j.splice(b, 1);
        j.length >= d && b < d && (a = j[d - 1], c(a));
    }
    function c(a) {
        var b = new XMLHttpRequest(), c = f(), j = {}, t;
        l.onSend(a);
        l.paramsStore.getParams && (j = l.paramsStore.getParams(a));
        t = j;
        var m = l.endpointStore.getEndpoint(a), w = s[a].addToPath;
        void 0 !== w && (m += "/" + w);
        t = i && t ? qq.obj2url(t, m) : m;
        s[a].xhr = b;
        b.onreadystatechange = d(a);
        b.open(c, t, !0);
        l.cors.expected && l.cors.sendCredentials && (b.withCredentials = !0);
        e(a);
        g("Sending " + c + " request for " + a);
        !i && j ? b.send(qq.obj2url(j, "")) : b.send();
    }
    function d(a) {
        var c = s[a].xhr;
        return function() {
            if (4 === c.readyState) {
                var d = s[a].xhr, e = f(), j = !1;
                b(a);
                0 <= qq.indexOf(l.successfulResponseCodes, d.status) || (j = !0, g(e + " request for " + a + " has failed - response code " + d.status, "error"));
                l.onComplete(a, d, j);
            }
        };
    }
    function e(a) {
        var b = s[a].xhr, a = l.customHeaders;
        b.setRequestHeader("X-Requested-With", "XMLHttpRequest");
        b.setRequestHeader("Cache-Control", "no-cache");
        qq.each(a, function(a, c) {
            b.setRequestHeader(a, c);
        });
    }
    function f() {
        return l.demoMode ? "GET" : l.method;
    }
    var g, i, j = [], s = [], l = {
        method: "POST",
        maxConnections: 3,
        customHeaders: {},
        endpointStore: {},
        paramsStore: {},
        successfulResponseCodes: [ 200 ],
        demoMode: !1,
        cors: {
            expected: !1,
            sendCredentials: !1
        },
        log: function() {},
        onSend: function() {},
        onComplete: function() {},
        onCancel: function() {}
    };
    qq.extend(l, a);
    g = l.log;
    i = "GET" === f() || "DELETE" === f();
    return {
        send: function(a, b) {
            s[a] = {
                addToPath: b
            };
            j.push(a) <= l.maxConnections && c(a);
        },
        cancel: function(a) {
            var c = s[a].xhr, d = f();
            c ? (c.onreadystatechange = null, c.abort(), b(a), g("Cancelled " + d + " for " + a), 
            l.onCancel(a), a = !0) : a = !1;
            return a;
        }
    };
};

qq.DeleteFileAjaxRequestor = function(a) {
    var b, c = {
        endpointStore: {},
        maxConnections: 3,
        customHeaders: {},
        paramsStore: {},
        demoMode: !1,
        cors: {
            expected: !1,
            sendCredentials: !1
        },
        log: function() {},
        onDelete: function() {},
        onDeleteComplete: function() {}
    };
    qq.extend(c, a);
    b = new qq.AjaxRequestor({
        method: "DELETE",
        endpointStore: c.endpointStore,
        paramsStore: c.paramsStore,
        maxConnections: c.maxConnections,
        customHeaders: c.customHeaders,
        successfulResponseCodes: [ 200, 202, 204 ],
        demoMode: c.demoMode,
        log: c.log,
        onSend: c.onDelete,
        onComplete: c.onDeleteComplete
    });
    return {
        sendDelete: function(a, e) {
            b.send(a, e);
            c.log("Submitted delete file request for " + a);
        }
    };
};

qq.WindowReceiveMessage = function(a) {
    var b = {};
    qq.extend({
        log: function() {}
    }, a);
    return {
        receiveMessage: function(a, d) {
            var e = function(a) {
                d(a.data);
            };
            window.postMessage ? b[a] = qq(window).attach("message", e) : log("iframe message passing not supported in this browser!", "error");
        },
        stopReceivingMessages: function(a) {
            window.postMessage && (a = b[a]) && a();
        }
    };
};

qq.UploadHandler = function(a) {
    function b(a) {
        var a = qq.indexOf(d, a), b = e.maxConnections;
        0 <= a && (d.splice(a, 1), d.length >= b && a < b && (a = d[b - 1], g.upload(a)));
    }
    function c(a) {
        f("Cancelling " + a);
        e.paramsStore.remove(a);
        b(a);
    }
    var d = [], e, f, g, i;
    e = {
        debug: !1,
        forceMultipart: !0,
        paramsInBody: !1,
        paramsStore: {},
        endpointStore: {},
        cors: {
            expected: !1,
            sendCredentials: !1
        },
        maxConnections: 3,
        uuidParamName: "qquuid",
        totalFileSizeParamName: "qqtotalfilesize",
        chunking: {
            enabled: !1,
            partSize: 2e6,
            paramNames: {
                partIndex: "qqpartindex",
                partByteOffset: "qqpartbyteoffset",
                chunkSize: "qqchunksize",
                totalParts: "qqtotalparts",
                filename: "qqfilename"
            }
        },
        resume: {
            enabled: !1,
            id: null,
            cookiesExpireIn: 7,
            paramNames: {
                resuming: "qqresume"
            }
        },
        blobs: {
            paramNames: {
                name: "qqblobname"
            }
        },
        log: function() {},
        onProgress: function() {},
        onComplete: function() {},
        onCancel: function() {},
        onUpload: function() {},
        onUploadChunk: function() {},
        onAutoRetry: function() {},
        onResume: function() {},
        onUuidChanged: function() {}
    };
    qq.extend(e, a);
    f = e.log;
    g = qq.supportedFeatures.ajaxUploading ? new qq.UploadHandlerXhr(e, b, e.onUuidChanged, f) : new qq.UploadHandlerForm(e, b, e.onUuidChanged, f);
    return i = {
        add: function(a) {
            return g.add(a);
        },
        upload: function(a) {
            return d.push(a) <= e.maxConnections ? (g.upload(a), !0) : !1;
        },
        retry: function(a) {
            return 0 <= qq.indexOf(d, a) ? g.upload(a, !0) : this.upload(a);
        },
        cancel: function(a) {
            var b = g.cancel(a);
            qq.isPromise(b) ? b.then(function() {
                c(a);
            }) : !1 !== b && c(a);
        },
        cancelAll: function() {
            var a = this, b = [];
            qq.extend(b, d);
            qq.each(b, function(b, c) {
                a.cancel(c);
            });
            d = [];
        },
        getName: function(a) {
            return g.getName(a);
        },
        getSize: function(a) {
            if (g.getSize) return g.getSize(a);
        },
        getFile: function(a) {
            if (g.getFile) return g.getFile(a);
        },
        reset: function() {
            f("Resetting upload handler");
            i.cancelAll();
            d = [];
            g.reset();
        },
        expunge: function(a) {
            return g.expunge(a);
        },
        getUuid: function(a) {
            return g.getUuid(a);
        },
        isValid: function(a) {
            return g.isValid(a);
        },
        getResumableFilesData: function() {
            return g.getResumableFilesData ? g.getResumableFilesData() : [];
        }
    };
};

qq.UploadHandlerForm = function(a, b, c, d) {
    function e(a) {
        void 0 !== v[a] && (v[a](), delete v[a]);
    }
    function f(a, b) {
        var c = a.id, d = c.split("_")[0];
        y[u[d]] = b;
        v[d] = qq(a).attach("load", function() {
            q[d] && (m("Received iframe load event for CORS upload request (iframe name " + c + ")"), 
            t[c] = setTimeout(function() {
                var a = "No valid message received from loaded iframe for iframe name " + c;
                m(a, "error");
                b({
                    error: a
                });
            }, 1e3));
        });
        w.receiveMessage(c, function(a) {
            m("Received the following window message: '" + a + "'");
            var b = i(c.split("_")[0], a), d = b.uuid;
            d && y[d] ? (m("Handling response for iframe name " + c), clearTimeout(t[c]), delete t[c], 
            e(c), a = y[d], delete y[d], w.stopReceivingMessages(c), a(b)) : d || m("'" + a + "' does not contain a UUID - ignoring.");
        });
    }
    function g(a, b) {
        n.cors.expected ? f(a, b) : v[a.id] = qq(a).attach("load", function() {
            m("Received response for " + a.id);
            if (a.parentNode) {
                try {
                    if (a.contentDocument && a.contentDocument.body && "false" == a.contentDocument.body.innerHTML) return;
                } catch (c) {
                    m("Error when attempting to access iframe during handling of upload response (" + c + ")", "error");
                }
                b();
            }
        });
    }
    function i(a, b) {
        var d;
        try {
            d = qq.parseJson(b), void 0 !== d.newUuid && (m("Server requested UUID change from '" + u[a] + "' to '" + d.newUuid + "'"), 
            u[a] = d.newUuid, c(a, d.newUuid));
        } catch (e) {
            m("Error when attempting to parse iframe upload response (" + e + ")", "error"), 
            d = {};
        }
        return d;
    }
    function j(a) {
        var a = a + "_" + x, b = qq.toElement('<iframe src="javascript:false;" name="' + a + '" />');
        b.setAttribute("id", a);
        b.style.display = "none";
        document.body.appendChild(b);
        return b;
    }
    function s(a, b) {
        var c = n.paramsStore.getParams(a), d = qq.toElement('<form method="' + (n.demoMode ? "GET" : "POST") + '" enctype="multipart/form-data"></form>'), e = n.endpointStore.getEndpoint(a), f = e;
        c[n.uuidParamName] = u[a];
        n.paramsInBody ? qq.obj2Inputs(c, d) : f = qq.obj2url(c, e);
        d.setAttribute("action", f);
        d.setAttribute("target", b.name);
        d.style.display = "none";
        document.body.appendChild(d);
        return d;
    }
    function l(a) {
        delete q[a];
        delete u[a];
        delete v[a];
        n.cors.expected && (clearTimeout(t[a]), delete t[a], w.stopReceivingMessages(a));
        if (a = document.getElementById(a + "_" + x)) a.setAttribute("src", "java" + String.fromCharCode(115) + "cript:false;"), 
        qq(a).remove();
    }
    var n = a, q = [], u = [], v = {}, t = {}, m = d, w = new qq.WindowReceiveMessage({
        log: m
    }), y = {}, x = qq.getUniqueId(), z;
    return z = {
        add: function(a) {
            a.setAttribute("name", n.inputName);
            var b = q.push(a) - 1;
            u[b] = qq.getUniqueId();
            a.parentNode && qq(a).remove();
            return b;
        },
        getName: function(a) {
            if (z.isValid(a)) return q[a].value.replace(/.*(\/|\\)/, "");
            m(a + " is not a valid item ID.", "error");
        },
        isValid: function(a) {
            return void 0 !== q[a];
        },
        reset: function() {
            q = [];
            u = [];
            v = {};
            x = qq.getUniqueId();
        },
        expunge: function(a) {
            return l(a);
        },
        getUuid: function(a) {
            return u[a];
        },
        cancel: function(a) {
            var b = n.onCancel(a, z.getName(a));
            return qq.isPromise(b) ? b.then(function() {
                l(a);
            }) : !1 !== b ? (l(a), !0) : !1;
        },
        upload: function(a) {
            var c = q[a], d = z.getName(a), f = j(a), l;
            if (!c) throw Error("file with passed id was not added, or already uploaded or cancelled");
            n.onUpload(a, z.getName(a));
            l = s(a, f);
            l.appendChild(c);
            g(f, function(c) {
                m("iframe loaded");
                if (!c) {
                    var h;
                    try {
                        var g = f.contentDocument || f.contentWindow.document, j = g.body.innerHTML;
                        m("converting iframe's innerHTML to JSON");
                        m("innerHTML = " + j);
                        j && j.match(/^<pre/i) && (j = g.body.firstChild.firstChild.nodeValue);
                        h = i(a, j);
                    } catch (l) {
                        m("Error when attempting to parse form upload response (" + l + ")", "error"), h = {
                            success: !1
                        };
                    }
                    c = h;
                }
                e(a);
                n.cors.expected || qq(f).remove();
                if (c.success || !n.onAutoRetry(a, d, c)) n.onComplete(a, d, c), b(a);
            });
            m("Sending upload request for " + a);
            l.submit();
            qq(l).remove();
        }
    };
};

qq.UploadHandlerXhr = function(a, b, c, d) {
    function e(a, b, c) {
        var d = p.getSize(a), a = p.getName(a);
        b[k.chunking.paramNames.partIndex] = c.part;
        b[k.chunking.paramNames.partByteOffset] = c.start;
        b[k.chunking.paramNames.chunkSize] = c.size;
        b[k.chunking.paramNames.totalParts] = c.count;
        b[k.totalFileSizeParamName] = d;
        B && (b[k.chunking.paramNames.filename] = a);
    }
    function f(a, b) {
        var c = k.chunking.partSize, d = p.getSize(a), e = h[a].file || h[a].blobData.blob, f = c * b, c = f + c >= d ? d : f + c, d = g(a), i;
        e.slice ? i = e.slice(f, c) : e.mozSlice ? i = e.mozSlice(f, c) : e.webkitSlice && (i = e.webkitSlice(f, c));
        return {
            part: b,
            start: f,
            end: c,
            count: d,
            blob: i,
            size: c - f
        };
    }
    function g(a) {
        a = p.getSize(a);
        return Math.ceil(a / k.chunking.partSize);
    }
    function i(a) {
        var b = new XMLHttpRequest();
        return h[a].xhr = b;
    }
    function j(a, b, c, d) {
        var e = new FormData(), f = k.demoMode ? "GET" : "POST", g = k.endpointStore.getEndpoint(d), i = g, j = p.getName(d), l = p.getSize(d), m = h[d].blobData;
        a[k.uuidParamName] = h[d].uuid;
        B && (a[k.totalFileSizeParamName] = l, m && (a[k.blobs.paramNames.name] = m.name));
        k.paramsInBody || (B || (a[k.inputName] = j), i = qq.obj2url(a, g));
        b.open(f, i, !0);
        k.cors.expected && k.cors.sendCredentials && (b.withCredentials = !0);
        return B ? (k.paramsInBody && qq.obj2FormData(a, e), e.append(k.inputName, c), e) : c;
    }
    function s(a, b) {
        var c = k.customHeaders, d = h[a].file || h[a].blobData.blob;
        b.setRequestHeader("X-Requested-With", "XMLHttpRequest");
        b.setRequestHeader("Cache-Control", "no-cache");
        B || (b.setRequestHeader("Content-Type", "application/octet-stream"), b.setRequestHeader("X-Mime-Type", d.type));
        qq.each(c, function(a, c) {
            b.setRequestHeader(a, c);
        });
    }
    function l(a, b, c) {
        var d = p.getName(a), e = p.getSize(a);
        h[a].attemptingResume = !1;
        k.onProgress(a, d, e, e);
        k.onComplete(a, d, b, c);
        h[a] && delete h[a].xhr;
        H(a);
    }
    function n(a) {
        var b = h[a].remainingChunkIdxs[0], c = f(a, b), d = i(a), g = p.getSize(a), l = p.getName(a), m;
        void 0 === h[a].loaded && (h[a].loaded = 0);
        A && h[a].file && t(a, c);
        d.onreadystatechange = v(a, d);
        d.upload.onprogress = function(c) {
            if (c.lengthComputable) {
                var d = c.loaded + h[a].loaded, c = c.total, e = f(a, b), c = c - e.size, g = p.getSize(a), e = e.count, i = c - h[a].initialRequestOverhead;
                h[a].lastRequestOverhead = c;
                if (b === 0) {
                    h[a].lastChunkIdxProgress = 0;
                    h[a].initialRequestOverhead = c;
                    h[a].estTotalRequestsSize = g + e * c;
                } else if (h[a].lastChunkIdxProgress !== b) {
                    h[a].lastChunkIdxProgress = b;
                    h[a].estTotalRequestsSize = h[a].estTotalRequestsSize + i;
                }
                k.onProgress(a, l, d, h[a].estTotalRequestsSize);
            }
        };
        k.onUploadChunk(a, l, u(c));
        m = k.paramsStore.getParams(a);
        e(a, m, c);
        h[a].attemptingResume && (m[k.resume.paramNames.resuming] = !0);
        m = j(m, d, c.blob, a);
        s(a, d);
        r("Sending chunked upload request for item " + a + ": bytes " + (c.start + 1) + "-" + c.end + " of " + g);
        d.send(m);
    }
    function q(a) {
        r("Server has ordered chunking effort to be restarted on next attempt for item ID " + a, "error");
        A && (m(a), h[a].attemptingResume = !1);
        h[a].remainingChunkIdxs = [];
        delete h[a].loaded;
        delete h[a].estTotalRequestsSize;
        delete h[a].initialRequestOverhead;
    }
    function u(a) {
        return {
            partIndex: a.part,
            startByte: a.start + 1,
            endByte: a.end,
            totalParts: a.count
        };
    }
    function v(a, b) {
        return function() {
            if (4 === b.readyState) {
                var d;
                if (h[a]) {
                    r("xhr - server response received for " + a);
                    r("responseText = " + b.responseText);
                    try {
                        d = qq.parseJson(b.responseText), void 0 !== d.newUuid && (r("Server requested UUID change from '" + h[a].uuid + "' to '" + d.newUuid + "'"), 
                        h[a].uuid = d.newUuid, c(a, d.newUuid));
                    } catch (e) {
                        r("Error when attempting to parse xhr response text (" + e + ")", "error"), d = {};
                    }
                    if (200 !== b.status || !d.success || d.reset) if (d.reset && q(a), h[a].attemptingResume && d.reset) h[a].attemptingResume = !1, 
                    r("Server has declared that it cannot handle resume for item ID " + a + " - starting from the first chunk", "error"), 
                    q(a), p.upload(a, !0); else {
                        var g = p.getName(a);
                        k.onAutoRetry(a, g, d, b) || l(a, d, b);
                    } else if (D) {
                        var g = h[a].remainingChunkIdxs.shift(), i = f(a, g);
                        h[a].attemptingResume = !1;
                        var g = h[a], j = g.loaded, i = i.size, o;
                        o = B ? h[a].lastRequestOverhead : 0;
                        g.loaded = j + (i + o);
                        0 < h[a].remainingChunkIdxs.length ? n(a) : (A && m(a), l(a, d, b));
                    } else l(a, d, b);
                }
            }
        };
    }
    function t(a, b) {
        var c = p.getUuid(a), d = h[a].loaded, e = h[a].initialRequestOverhead, f = h[a].estTotalRequestsSize, g = y(a);
        qq.setCookie(g, c + o + b.part + o + d + o + e + o + f, k.resume.cookiesExpireIn);
    }
    function m(a) {
        h[a].file && (a = y(a), qq.deleteCookie(a));
    }
    function w(a) {
        var b = qq.getCookie(y(a)), a = p.getName(a), c, d, e;
        if (b) {
            b = b.split(o);
            if (5 === b.length) return a = b[0], c = parseInt(b[1], 10), d = parseInt(b[2], 10), 
            e = parseInt(b[3], 10), b = parseInt(b[4], 10), {
                uuid: a,
                part: c,
                lastByteSent: d,
                initialRequestOverhead: e,
                estTotalRequestsSize: b
            };
            r("Ignoring previously stored resume/chunk cookie for " + a + " - old cookie format", "warn");
        }
    }
    function y(a) {
        var b = p.getName(a), a = p.getSize(a), c = k.chunking.partSize, b = "qqfilechunk" + o + encodeURIComponent(b) + o + a + o + c;
        void 0 !== C && (b += o + C);
        return b;
    }
    function x(a, b) {
        var c;
        for (c = g(a) - 1; c >= b; c -= 1) h[a].remainingChunkIdxs.unshift(c);
        n(a);
    }
    function z(a, b, c, d) {
        c = d.part;
        h[a].loaded = d.lastByteSent;
        h[a].estTotalRequestsSize = d.estTotalRequestsSize;
        h[a].initialRequestOverhead = d.initialRequestOverhead;
        h[a].attemptingResume = !0;
        r("Resuming " + b + " at partition index " + c);
        x(a, c);
    }
    function F(a, b, c) {
        var d = p.getName(a), e = f(a, b.part), e = k.onResume(a, d, u(e));
        qq.isPromise(e) ? (r("Waiting for onResume promise to be fulfilled for " + a), e.then(function() {
            z(a, d, c, b);
        }, function() {
            r("onResume promise fulfilled - failure indicated.  Will not resume.");
            x(a, c);
        })) : !1 !== e ? z(a, d, c, b) : (r("onResume callback returned false.  Will not resume."), 
        x(a, c));
    }
    function G(a) {
        var b = h[a].file || h[a].blobData.blob, c = p.getName(a), d, e;
        h[a].loaded = 0;
        d = i(a);
        d.upload.onprogress = function(b) {
            b.lengthComputable && (h[a].loaded = b.loaded, k.onProgress(a, c, b.loaded, b.total));
        };
        d.onreadystatechange = v(a, d);
        e = k.paramsStore.getParams(a);
        b = j(e, d, b, a);
        s(a, d);
        r("Sending upload request for " + a);
        d.send(b);
    }
    function E(a) {
        var b = h[a].xhr;
        b && (b.onreadystatechange = null, b.abort());
        A && m(a);
        delete h[a];
    }
    var k = a, H = b, r = d, h = [], o = "|", D = k.chunking.enabled && qq.supportedFeatures.chunking, A = k.resume.enabled && D && qq.supportedFeatures.resume, C;
    C = null !== k.resume.id && void 0 !== k.resume.id && !qq.isFunction(k.resume.id) && !qq.isObject(k.resume.id) ? k.resume.id : void 0;
    var B = k.forceMultipart || k.paramsInBody, p;
    return p = {
        add: function(a) {
            var b, c = qq.getUniqueId();
            if (qq.isFile(a)) a = h.push({
                file: a
            }) - 1; else if (qq.isBlob(a.blob)) a = h.push({
                blobData: a
            }) - 1; else throw Error("Passed obj in not a File or BlobData (in qq.UploadHandlerXhr)");
            if (A && (b = w(a))) c = b.uuid;
            h[a].uuid = c;
            return a;
        },
        getName: function(a) {
            if (p.isValid(a)) {
                var b = h[a].file, a = h[a].blobData;
                return b ? null !== b.fileName && void 0 !== b.fileName ? b.fileName : b.name : a.name;
            }
            r(a + " is not a valid item ID.", "error");
        },
        getSize: function(a) {
            a = h[a].file || h[a].blobData.blob;
            return qq.isFileOrInput(a) ? null != a.fileSize ? a.fileSize : a.size : a.size;
        },
        getFile: function(a) {
            if (h[a]) return h[a].file || h[a].blobData.blob;
        },
        isValid: function(a) {
            return void 0 !== h[a];
        },
        reset: function() {
            h = [];
        },
        expunge: function(a) {
            return E(a);
        },
        getUuid: function(a) {
            return h[a].uuid;
        },
        upload: function(a, b) {
            var c = this.getName(a);
            this.isValid(a) && (k.onUpload(a, c), D ? !h[a].remainingChunkIdxs || 0 === h[a].remainingChunkIdxs.length ? (h[a].remainingChunkIdxs = [], 
            A && !b && h[a].file ? (c = w(a)) ? F(a, c, 0) : x(a, 0) : x(a, 0)) : n(a) : G(a));
        },
        cancel: function(a) {
            var b = k.onCancel(a, this.getName(a));
            return qq.isPromise(b) ? b.then(function() {
                E(a);
            }) : !1 !== b ? (E(a), !0) : !1;
        },
        getResumableFilesData: function() {
            var a = [], b = [];
            return D && A ? (a = void 0 === C ? qq.getCookieNames(RegExp("^qqfilechunk\\" + o + ".+\\" + o + "\\d+\\" + o + k.chunking.partSize + "=")) : qq.getCookieNames(RegExp("^qqfilechunk\\" + o + ".+\\" + o + "\\d+\\" + o + k.chunking.partSize + "\\" + o + C + "=")), 
            qq.each(a, function(a, c) {
                var d = c.split(o), e = qq.getCookie(c).split(o);
                b.push({
                    name: decodeURIComponent(d[1]),
                    size: d[2],
                    uuid: e[0],
                    partIdx: e[1]
                });
            }), b) : [];
        }
    };
};

//! END
/*!
 * ------/ Source: plugins/media.match.min.js
 */
/* MediaMatch v.2.0.2 - Testing css media queries in Javascript. Authors & copyright (c) 2013: WebLinc, David Knight. */
window.matchMedia || (window.matchMedia = function(c) {
    var a = c.document, w = a.documentElement, l = [], t = 0, x = "", h = {}, G = /\s*(only|not)?\s*(screen|print|[a-z\-]+)\s*(and)?\s*/i, H = /^\s*\(\s*(-[a-z]+-)?(min-|max-)?([a-z\-]+)\s*(:?\s*([0-9]+(\.[0-9]+)?|portrait|landscape)(px|em|dppx|dpcm|rem|%|in|cm|mm|ex|pt|pc|\/([0-9]+(\.[0-9]+)?))?)?\s*\)\s*$/, y = 0, A = function(b) {
        var z = -1 !== b.indexOf(",") && b.split(",") || [ b ], e = z.length - 1, j = e, g = null, d = null, c = "", a = 0, l = !1, m = "", f = "", g = null, d = 0, f = null, k = "", p = "", q = "", n = "", r = "", k = !1;
        if ("" === b) return !0;
        do {
            g = z[j - e];
            l = !1;
            if (d = g.match(G)) c = d[0], a = d.index;
            if (!d || -1 === g.substring(0, a).indexOf("(") && (a || !d[3] && c !== d.input)) k = !1; else {
                f = g;
                l = "not" === d[1];
                a || (m = d[2], f = g.substring(c.length));
                k = m === x || "all" === m || "" === m;
                g = -1 !== f.indexOf(" and ") && f.split(" and ") || [ f ];
                d = g.length - 1;
                if (k && 0 <= d && "" !== f) {
                    do {
                        f = g[d].match(H);
                        if (!f || !h[f[3]]) {
                            k = !1;
                            break;
                        }
                        k = f[2];
                        n = p = f[5];
                        q = f[7];
                        r = h[f[3]];
                        q && (n = "px" === q ? Number(p) : "em" === q || "rem" === q ? 16 * p : f[8] ? (p / f[8]).toFixed(2) : "dppx" === q ? 96 * p : "dpcm" === q ? .3937 * p : Number(p));
                        k = "min-" === k && n ? r >= n : "max-" === k && n ? r <= n : n ? r === n : !!r;
                        if (!k) break;
                    } while (d--);
                }
                if (k) break;
            }
        } while (e--);
        return l ? !k : k;
    }, B = function() {
        var b = c.innerWidth || w.clientWidth, a = c.innerHeight || w.clientHeight, e = c.screen.width, j = c.screen.height, g = c.screen.colorDepth, d = c.devicePixelRatio;
        h.width = b;
        h.height = a;
        h["aspect-ratio"] = (b / a).toFixed(2);
        h["device-width"] = e;
        h["device-height"] = j;
        h["device-aspect-ratio"] = (e / j).toFixed(2);
        h.color = g;
        h["color-index"] = Math.pow(2, g);
        h.orientation = a >= b ? "portrait" : "landscape";
        h.resolution = d && 96 * d || c.screen.deviceXDPI || 96;
        h["device-pixel-ratio"] = d || 1;
    }, C = function() {
        clearTimeout(y);
        y = setTimeout(function() {
            var b = null, a = t - 1, e = a, j = !1;
            if (0 <= a) {
                B();
                do if (b = l[e - a]) if ((j = A(b.mql.media)) && !b.mql.matches || !j && b.mql.matches) if (b.mql.matches = j, 
                b.listeners) for (var j = 0, g = b.listeners.length; j < g; j++) b.listeners[j] && b.listeners[j].call(c, b.mql); while (a--);
            }
        }, 10);
    }, D = a.getElementsByTagName("head")[0], a = a.createElement("style"), E = null, u = "screen print speech projection handheld tv braille embossed tty".split(" "), m = 0, I = u.length, s = "#mediamatchjs { position: relative; z-index: 0; }", v = "", F = c.addEventListener || (v = "on") && c.attachEvent;
    a.type = "text/css";
    a.id = "mediamatchjs";
    D.appendChild(a);
    for (E = c.getComputedStyle && c.getComputedStyle(a) || a.currentStyle; m < I; m++) s += "@media " + u[m] + " { #mediamatchjs { position: relative; z-index: " + m + " } }";
    a.styleSheet ? a.styleSheet.cssText = s : a.textContent = s;
    x = u[1 * E.zIndex || 0];
    D.removeChild(a);
    B();
    F(v + "resize", C);
    F(v + "orientationchange", C);
    return function(a) {
        var c = t, e = {
            matches: !1,
            media: a,
            addListener: function(a) {
                l[c].listeners || (l[c].listeners = []);
                a && l[c].listeners.push(a);
            },
            removeListener: function(a) {
                var b = l[c], d = 0, e = 0;
                if (b) for (e = b.listeners.length; d < e; d++) b.listeners[d] === a && b.listeners.splice(d, 1);
            }
        };
        if ("" === a) return e.matches = !0, e;
        e.matches = A(a);
        t = l.push({
            mql: e,
            listeners: null
        });
        return e;
    };
}(window));

//! END
/*!
 * ------/ Source: plugins/enquire.min.js
 */
// enquire.js v2.0.2 - Awesome Media Queries in JavaScript
// Copyright (c) 2013 Nick Williams - http://wicky.nillia.ms/enquire.js
// License: MIT (http://www.opensource.org/licenses/mit-license.php)
(function(t) {
    "use strict";
    function i(t, i) {
        var s, n = 0, e = t.length;
        for (n; e > n && (s = i(t[n], n), s !== !1); n++) ;
    }
    function s(t) {
        return "[object Array]" === Object.prototype.toString.apply(t);
    }
    function n(t) {
        return "function" == typeof t;
    }
    function e(t) {
        this.options = t, !t.deferSetup && this.setup();
    }
    function o(t, i) {
        this.query = t, this.isUnconditional = i, this.handlers = [], this.mql = h(t);
        var s = this;
        this.listener = function(t) {
            s.mql = t, s.assess();
        }, this.mql.addListener(this.listener);
    }
    function r() {
        if (!h) throw Error("matchMedia not present, legacy browsers require a polyfill");
        this.queries = {}, this.browserIsIncapable = !h("only all").matches;
    }
    var h = t.matchMedia;
    e.prototype = {
        setup: function() {
            this.options.setup && this.options.setup(), this.initialised = !0;
        },
        on: function() {
            !this.initialised && this.setup(), this.options.match && this.options.match();
        },
        off: function() {
            this.options.unmatch && this.options.unmatch();
        },
        destroy: function() {
            this.options.destroy ? this.options.destroy() : this.off();
        },
        equals: function(t) {
            return this.options === t || this.options.match === t;
        }
    }, o.prototype = {
        addHandler: function(t) {
            var i = new e(t);
            this.handlers.push(i), this.matches() && i.on();
        },
        removeHandler: function(t) {
            var s = this.handlers;
            i(s, function(i, n) {
                return i.equals(t) ? (i.destroy(), !s.splice(n, 1)) : void 0;
            });
        },
        matches: function() {
            return this.mql.matches || this.isUnconditional;
        },
        clear: function() {
            i(this.handlers, function(t) {
                t.destroy();
            }), this.mql.removeListener(this.listener), this.handlers.length = 0;
        },
        assess: function() {
            var t = this.matches() ? "on" : "off";
            i(this.handlers, function(i) {
                i[t]();
            });
        }
    }, r.prototype = {
        register: function(t, e, r) {
            var h = this.queries, a = r && this.browserIsIncapable;
            return h[t] || (h[t] = new o(t, a)), n(e) && (e = {
                match: e
            }), s(e) || (e = [ e ]), i(e, function(i) {
                h[t].addHandler(i);
            }), this;
        },
        unregister: function(t, i) {
            var s = this.queries[t];
            return s && (i ? s.removeHandler(i) : (s.clear(), delete this.queries[t])), this;
        }
    }, t.enquire = t.enquire || new r();
})(this);